<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/VOTE_FIX_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/VOTE_FIX_SUMMARY.md" />
              <option name="updatedContent" value="# Fix: activeGame.votes Not Showing After Player Vote&#10;&#10;## Problem&#10;After calling `playerVote()`, the `activeGame` field `votes` was not visible in the frontend.&#10;&#10;## Root Causes&#10;&#10;### 1. **Backend**: Votes field was missing from active_game response&#10;The `currentGame()` handler in `RoomWebSocketController` was not including the `votes` field when building the gameMap response.&#10;&#10;### 2. **Frontend**: No request for updated activeGame after voting&#10;The `playerVote()` function was sending the vote but not requesting the updated active game data to see the votes.&#10;&#10;### 3. **Frontend**: Missing VOTE_CAST trigger&#10;The room update subscription wasn't listening for `VOTE_CAST` events to trigger an active game refresh.&#10;&#10;## Solution&#10;&#10;### Backend Fix ✅&#10;**File**: `RoomWebSocketController.java`&#10;&#10;Added `votes` field to the active_game response payload:&#10;&#10;```java&#10;gameMap.put(&quot;votes&quot;, g.getVotes());&#10;```&#10;&#10;Now when clients request `/app/room/{roomCode}/active_game`, they receive:&#10;```json&#10;{&#10;  &quot;game&quot;: {&#10;    &quot;id&quot;: &quot;...&quot;,&#10;    &quot;votes&quot;: {&#10;      &quot;player-uuid-1&quot;: &quot;target-uuid-a&quot;,&#10;      &quot;player-uuid-2&quot;: &quot;target-uuid-b&quot;&#10;    },&#10;    &quot;cardOpened&quot;: {...},&#10;    ...&#10;  }&#10;}&#10;```&#10;&#10;### Frontend Fix ✅&#10;**File**: `useRoomWebSocket.ts` (or `useRoomWebSocket_updated.ts`)&#10;&#10;#### 1. Added VOTE_CAST listener&#10;```typescript&#10;if (&#10;  update.type === &quot;CARD_OPENED&quot; ||&#10;  update.type === &quot;GAME_STARTED&quot; ||&#10;  update.type === &quot;VOTE_CAST&quot; ||      // ← NEW&#10;  update.type === &quot;VOTE_STARTED&quot; ||   // ← NEW&#10;  (update.activeGame !== undefined &amp;&amp; update.activeGame !== null)&#10;) {&#10;  // Request updated active game&#10;  clientRef.current.publish({&#10;    destination: `/app/room/${roomCode}/active_game`,&#10;    body: JSON.stringify({ playerUuid }),&#10;  });&#10;}&#10;```&#10;&#10;#### 2. Auto-request after voting&#10;```typescript&#10;const playerVote = useCallback(&#10;  (targetPlayerUuid: string) =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      // Send vote&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/vote`,&#10;        body: JSON.stringify({ playerUuid, targetPlayerUuid }),&#10;      });&#10;      &#10;      // Immediately request active game to see updated votes&#10;      setTimeout(() =&gt; {&#10;        if (clientRef.current?.connected) {&#10;          clientRef.current.publish({&#10;            destination: `/app/room/${roomCode}/active_game`,&#10;            body: JSON.stringify({ playerUuid }),&#10;          });&#10;        }&#10;      }, 100);&#10;    }&#10;  },&#10;  [roomCode, playerUuid, isConnected]&#10;);&#10;```&#10;&#10;## How It Works Now&#10;&#10;### Flow:&#10;1. **Player clicks vote** → `playerVote(targetUuid)` called&#10;2. **Vote sent** → Server receives at `/app/room/{roomCode}/vote`&#10;3. **Server updates** → `GameManager.recordVote()` stores vote in `Game.votes` map&#10;4. **Server broadcasts** → `VOTE_CAST` message to `/topic/room/{roomCode}`&#10;5. **Frontend receives** → `VOTE_CAST` in room subscription&#10;6. **Frontend requests** → `/app/room/{roomCode}/active_game`&#10;7. **Server responds** → `/user/queue/active_game` with updated votes field&#10;8. **Frontend updates** → `setActiveGame(game)` with votes visible&#10;&#10;### Result:&#10;```typescript&#10;activeGame.votes = {&#10;  &quot;uuid-player-1&quot;: &quot;uuid-target-a&quot;,&#10;  &quot;uuid-player-2&quot;: &quot;uuid-target-b&quot;,&#10;  &quot;uuid-player-3&quot;: &quot;uuid-target-a&quot;&#10;}&#10;```&#10;&#10;## Testing&#10;1. Start a game with multiple players&#10;2. Trigger voting phase (master_end)&#10;3. Each player calls `playerVote(targetUuid)`&#10;4. Check browser console for:&#10;   - `️ Player is voting for: [uuid]`&#10;   - `Room update received: { type: &quot;VOTE_CAST&quot; }`&#10;   - ` Requesting active game after vote...`&#10;   - ` active_game (user queue) received: { votes: {...} }`&#10;5. Verify `activeGame.votes` object in React state contains all votes&#10;&#10;## Additional Notes&#10;- Votes can be changed (new vote overwrites previous vote from same voter)&#10;- Only participants (players with roles) can vote&#10;- The `votes` map is initialized as empty `{}` when game is created&#10;- Votes persist across reconnects (stored in server memory via GameManager)&#10;&#10;## Files Modified&#10;1. `/src/main/java/com/insidergame/insider_api/websocket/RoomWebSocketController.java`&#10;2. `/hooks/useRoomWebSocket.ts` (create updated version as `useRoomWebSocket_updated.ts`)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/enums/RoomStatus.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/enums/RoomStatus.java" />
              <option name="originalContent" value="package com.insidergame.insider_api.enums;&#10;&#10;public enum RoomStatus {&#10;    WAITING ,&#10;    PLAYING,&#10;}&#10;" />
              <option name="updatedContent" value="package com.insidergame.insider_api.enums;&#10;&#10;public enum RoomStatus {&#10;    WAITING ,&#10;    PLAYING,&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>