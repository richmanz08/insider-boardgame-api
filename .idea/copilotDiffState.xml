<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/enums/RoomStatus.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/enums/RoomStatus.java" />
              <option name="originalContent" value="package com.insidergame.insider_api.enums;&#10;&#10;public enum RoomStatus {&#10;    WAITING ,&#10;    PLAYING,&#10;}&#10;" />
              <option name="updatedContent" value="package com.insidergame.insider_api.enums;&#10;&#10;public enum RoomStatus {&#10;    WAITING ,&#10;    PLAYING,&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/manager/GameManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/manager/GameManager.java" />
              <option name="originalContent" value="package com.insidergame.insider_api.manager;&#10;&#10;import com.insidergame.insider_api.model.Game;&#10;import com.insidergame.insider_api.enums.RoleType;&#10;import com.insidergame.insider_api.model.Player;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;@Component&#10;@RequiredArgsConstructor&#10;public class GameManager {&#10;    // roomCode -&gt; list of games&#10;    private final Map&lt;String, List&lt;Game&gt;&gt; gamesByRoom = new ConcurrentHashMap&lt;&gt;();&#10;    // active game per room&#10;    private final Map&lt;String, Game&gt; activeGameByRoom = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // Inject RoomManager to access players in a room (needed to detect bots)&#10;    private final RoomManager roomManager;&#10;&#10;    public Optional&lt;Game&gt; getActiveGame(String roomCode) {&#10;        return Optional.ofNullable(activeGameByRoom.get(roomCode));&#10;    }&#10;&#10;    public Game createGame(String roomCode, String word, int durationSeconds, Map&lt;String, RoleType&gt; roles) {&#10;        // convert roles map into model type (RoleType) stored in Game&#10;        Game game = Game.builder()&#10;                .id(UUID.randomUUID())&#10;                .roomCode(roomCode)&#10;                .word(word)&#10;                .roles(new HashMap&lt;&gt;(roles))&#10;                .startedAt(null)&#10;                .durationSeconds(durationSeconds)&#10;                .endsAt(null)&#10;                .finished(false)&#10;                .cardOpened(new HashMap&lt;&gt;())&#10;                .build();&#10;&#10;        // initialize cardOpened map for all players&#10;        for (String uuid : roles.keySet()) {&#10;            game.getCardOpened().put(uuid, false);&#10;        }&#10;&#10;        gamesByRoom.computeIfAbsent(roomCode, k -&gt; new ArrayList&lt;&gt;()).add(game);&#10;        activeGameByRoom.put(roomCode, game);&#10;        return game;&#10;    }&#10;&#10;    // Start the countdown for an active game (set startedAt and endsAt)&#10;    public Optional&lt;Game&gt; startCountdown(String roomCode) {&#10;        Game g = activeGameByRoom.get(roomCode);&#10;        if (g == null) return Optional.empty();&#10;&#10;        // Only start countdown when all players have opened their cards&#10;        Map&lt;String, Boolean&gt; cardOpened = g.getCardOpened();&#10;        if (cardOpened == null || cardOpened.isEmpty()) return Optional.empty();&#10;        boolean allOpened = cardOpened.values().stream().allMatch(Boolean::booleanValue);&#10;        if (!allOpened) {&#10;            // Not all players opened yet - do not start countdown&#10;            return Optional.empty();&#10;        }&#10;&#10;        // If countdown already started, return existing game&#10;        if (g.getStartedAt() != null &amp;&amp; g.getEndsAt() != null) {&#10;            return Optional.of(g);&#10;        }&#10;&#10;        // Start countdown now and persist times on the Game model so subsequent&#10;        // active_game requests (e.g. after refresh) won't reset the timer.&#10;        LocalDateTime now = LocalDateTime.now();&#10;        g.setStartedAt(now);&#10;        g.setEndsAt(now.plusSeconds(g.getDurationSeconds()));&#10;&#10;        return Optional.of(g);&#10;    }&#10;&#10;    // mark a player's card as opened, return true if changed&#10;    public boolean markCardOpened(String roomCode, String playerUuid) {&#10;        Game g = activeGameByRoom.get(roomCode);&#10;        if (g == null) return false;&#10;        Map&lt;String, Boolean&gt; map = g.getCardOpened();&#10;        if (map == null || !map.containsKey(playerUuid)) return false;&#10;        if (Boolean.TRUE.equals(map.get(playerUuid))) return false;&#10;        map.put(playerUuid, true);&#10;&#10;        // If the player who opened is the room host, also mark bots' cards as opened&#10;        try {&#10;            var roomOpt = roomManager.getRoom(roomCode);&#10;            if (roomOpt.isPresent()) {&#10;                var room = roomOpt.get();&#10;                String hostUuid = room.getHostUuid();&#10;                if (hostUuid != null &amp;&amp; hostUuid.equals(playerUuid)) {&#10;                    // Consider players whose name starts with &quot;Bot &quot; as bots (mocked in RoomServiceImpl)&#10;                    for (Player p : room.getPlayers()) {&#10;                        if (p == null) continue;&#10;                        String name = p.getPlayerName();&#10;                        if (name != null &amp;&amp; name.startsWith(&quot;Bot &quot;)) {&#10;                            String botUuid = p.getUuid();&#10;                            if (botUuid != null &amp;&amp; map.containsKey(botUuid) &amp;&amp; !Boolean.TRUE.equals(map.get(botUuid))) {&#10;                                map.put(botUuid, true);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (Exception ignored) {&#10;            // Don't fail card open if room lookup fails&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;&#10;    public void finishGame(String roomCode) {&#10;        Game g = activeGameByRoom.remove(roomCode);&#10;        if (g != null) {&#10;            g.setFinished(true);&#10;        }&#10;    }&#10;&#10;    public List&lt;Game&gt; getGamesForRoom(String roomCode) {&#10;        return gamesByRoom.getOrDefault(roomCode, Collections.emptyList());&#10;    }&#10;&#10;    // Record a vote during voting phase: voterUuid votes for targetUuid. Returns current tally map.&#10;    public Map&lt;String, Integer&gt; recordVote(String roomCode, String voterUuid, String targetUuid) {&#10;        Game g = activeGameByRoom.get(roomCode);&#10;        if (g == null) return Collections.emptyMap();&#10;        if (g.getVotes() == null) g.setVotes(new HashMap&lt;&gt;());&#10;        g.getVotes().put(voterUuid, targetUuid);&#10;&#10;        // compute tally&#10;        Map&lt;String, Integer&gt; tally = new HashMap&lt;&gt;();&#10;        for (String t : g.getVotes().values()) {&#10;            tally.put(t, tally.getOrDefault(t, 0) + 1);&#10;        }&#10;&#10;        return tally;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.insidergame.insider_api.manager;&#10;&#10;import com.insidergame.insider_api.model.Game;&#10;import com.insidergame.insider_api.enums.RoleType;&#10;import com.insidergame.insider_api.model.Player;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;@Component&#10;@RequiredArgsConstructor&#10;public class GameManager {&#10;    // roomCode -&gt; list of games&#10;    private final Map&lt;String, List&lt;Game&gt;&gt; gamesByRoom = new ConcurrentHashMap&lt;&gt;();&#10;    // active game per room&#10;    private final Map&lt;String, Game&gt; activeGameByRoom = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // Inject RoomManager to access players in a room (needed to detect bots)&#10;    private final RoomManager roomManager;&#10;&#10;    public Optional&lt;Game&gt; getActiveGame(String roomCode) {&#10;        return Optional.ofNullable(activeGameByRoom.get(roomCode));&#10;    }&#10;&#10;    public Game createGame(String roomCode, String word, int durationSeconds, Map&lt;String, RoleType&gt; roles) {&#10;        // convert roles map into model type (RoleType) stored in Game&#10;        Game game = Game.builder()&#10;                .id(UUID.randomUUID())&#10;                .roomCode(roomCode)&#10;                .word(word)&#10;                .roles(new HashMap&lt;&gt;(roles))&#10;                .startedAt(null)&#10;                .durationSeconds(durationSeconds)&#10;                .endsAt(null)&#10;                .finished(false)&#10;                .cardOpened(new HashMap&lt;&gt;())&#10;                .votes(new HashMap&lt;&gt;())&#10;                .build();&#10;&#10;        // initialize cardOpened map for all players&#10;        for (String uuid : roles.keySet()) {&#10;            game.getCardOpened().put(uuid, false);&#10;        }&#10;&#10;        gamesByRoom.computeIfAbsent(roomCode, k -&gt; new ArrayList&lt;&gt;()).add(game);&#10;        activeGameByRoom.put(roomCode, game);&#10;        return game;&#10;    }&#10;&#10;    // Start the countdown for an active game (set startedAt and endsAt)&#10;    public Optional&lt;Game&gt; startCountdown(String roomCode) {&#10;        Game g = activeGameByRoom.get(roomCode);&#10;        if (g == null) return Optional.empty();&#10;&#10;        // Only start countdown when all players have opened their cards&#10;        Map&lt;String, Boolean&gt; cardOpened = g.getCardOpened();&#10;        if (cardOpened == null || cardOpened.isEmpty()) return Optional.empty();&#10;        boolean allOpened = cardOpened.values().stream().allMatch(Boolean::booleanValue);&#10;        if (!allOpened) {&#10;            // Not all players opened yet - do not start countdown&#10;            return Optional.empty();&#10;        }&#10;&#10;        // If countdown already started, return existing game&#10;        if (g.getStartedAt() != null &amp;&amp; g.getEndsAt() != null) {&#10;            return Optional.of(g);&#10;        }&#10;&#10;        // Start countdown now and persist times on the Game model so subsequent&#10;        // active_game requests (e.g. after refresh) won't reset the timer.&#10;        LocalDateTime now = LocalDateTime.now();&#10;        g.setStartedAt(now);&#10;        g.setEndsAt(now.plusSeconds(g.getDurationSeconds()));&#10;&#10;        return Optional.of(g);&#10;    }&#10;&#10;    // mark a player's card as opened, return true if changed&#10;    public boolean markCardOpened(String roomCode, String playerUuid) {&#10;        Game g = activeGameByRoom.get(roomCode);&#10;        if (g == null) return false;&#10;        Map&lt;String, Boolean&gt; map = g.getCardOpened();&#10;        if (map == null || !map.containsKey(playerUuid)) return false;&#10;        if (Boolean.TRUE.equals(map.get(playerUuid))) return false;&#10;        map.put(playerUuid, true);&#10;&#10;        // If the player who opened is the room host, also mark bots' cards as opened&#10;        try {&#10;            var roomOpt = roomManager.getRoom(roomCode);&#10;            if (roomOpt.isPresent()) {&#10;                var room = roomOpt.get();&#10;                String hostUuid = room.getHostUuid();&#10;                if (hostUuid != null &amp;&amp; hostUuid.equals(playerUuid)) {&#10;                    // Consider players whose name starts with &quot;Bot &quot; as bots (mocked in RoomServiceImpl)&#10;                    for (Player p : room.getPlayers()) {&#10;                        if (p == null) continue;&#10;                        String name = p.getPlayerName();&#10;                        if (name != null &amp;&amp; name.startsWith(&quot;Bot &quot;)) {&#10;                            String botUuid = p.getUuid();&#10;                            if (botUuid != null &amp;&amp; map.containsKey(botUuid) &amp;&amp; !Boolean.TRUE.equals(map.get(botUuid))) {&#10;                                map.put(botUuid, true);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (Exception ignored) {&#10;            // Don't fail card open if room lookup fails&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;&#10;    public void finishGame(String roomCode) {&#10;        Game g = activeGameByRoom.remove(roomCode);&#10;        if (g != null) {&#10;            g.setFinished(true);&#10;        }&#10;    }&#10;&#10;    public List&lt;Game&gt; getGamesForRoom(String roomCode) {&#10;        return gamesByRoom.getOrDefault(roomCode, Collections.emptyList());&#10;    }&#10;&#10;    // Record a vote during voting phase: voterUuid votes for targetUuid. Returns current tally map.&#10;    public Map&lt;String, Integer&gt; recordVote(String roomCode, String voterUuid, String targetUuid) {&#10;        Game g = activeGameByRoom.get(roomCode);&#10;        if (g == null) return Collections.emptyMap();&#10;        if (g.getVotes() == null) g.setVotes(new HashMap&lt;&gt;());&#10;        g.getVotes().put(voterUuid, targetUuid);&#10;&#10;        // compute tally&#10;        Map&lt;String, Integer&gt; tally = new HashMap&lt;&gt;();&#10;        for (String t : g.getVotes().values()) {&#10;            tally.put(t, tally.getOrDefault(t, 0) + 1);&#10;        }&#10;&#10;        return tally;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>