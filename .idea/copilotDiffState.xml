<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/HOST_TRANSFER_FEATURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HOST_TRANSFER_FEATURE.md" />
              <option name="updatedContent" value="# Host Transfer Feature - Implementation Summary&#10;&#10;## ✅ Feature Overview&#10;ระบบถ่ายโอนหัวห้องอัตโนมัติเมื่อหัวห้องคนเดิม leave ออกไป โดยคนที่จะได้รับหัวห้องเป็นคนที่เข้ามาล่าสุดต่อจากหัวห้องคนเก่า&#10;&#10;##  How It Works&#10;&#10;### Logic Flow:&#10;```&#10;1. Host leaves room&#10;   ↓&#10;2. Find host's joinedAt timestamp&#10;   ↓&#10;3. Find player who joined RIGHT AFTER host&#10;   (smallest joinedAt &gt; host's joinedAt)&#10;   ↓&#10;4. Transfer host privileges to that player&#10;   ↓&#10;5. Broadcast &quot;HOST_TRANSFERRED&quot; message&#10;```&#10;&#10;### Example Scenario:&#10;```&#10;Room: ABC123&#10;Players joined in order:&#10;  1. Alice (Host)   - joinedAt: 10:00:00&#10;  2. Bob            - joinedAt: 10:00:05&#10;  3. Charlie        - joinedAt: 10:00:10&#10;  4. Dave           - joinedAt: 10:00:15&#10;&#10;When Alice leaves:&#10;  → Bob becomes new host (เข้ามาล่าสุดต่อจาก Alice)&#10;  &#10;When Bob leaves:&#10;  → Charlie becomes new host&#10;  &#10;When Charlie leaves:&#10;  → Dave becomes new host&#10;  &#10;When Dave leaves:&#10;  → Room is deleted (empty)&#10;```&#10;&#10;### Edge Cases Handled:&#10;&#10;#### Case 1: No player joined after host&#10;```&#10;Players:&#10;  1. Bob   - joinedAt: 10:00:05&#10;  2. Alice (Host) - joinedAt: 10:00:10&#10;&#10;When Alice leaves:&#10;  → Bob becomes host (wraparound to earliest player)&#10;```&#10;&#10;#### Case 2: Missing joinedAt timestamps&#10;```&#10;If timestamps are null:&#10;  → Fallback to first player in set&#10;```&#10;&#10;#### Case 3: Only 2 players&#10;```&#10;Players:&#10;  1. Alice (Host)&#10;  2. Bob&#10;&#10;When Alice leaves:&#10;  → Bob becomes host&#10;```&#10;&#10;#### Case 4: Host leaves, room empty&#10;```&#10;Players:&#10;  1. Alice (Host)&#10;&#10;When Alice leaves:&#10;  → Room is deleted&#10;```&#10;&#10;---&#10;&#10;##  Files Modified&#10;&#10;### 1. RoomManager.java&#10;**Location:** `/src/main/java/com/insidergame/insider_api/manager/RoomManager.java`&#10;&#10;**Changes:**&#10;- ✅ Updated `removePlayerFromRoom()` - Improved host transfer logic&#10;- ✅ Added `findNextHost()` - Find next host based on joinedAt timestamp&#10;&#10;**Key Methods:**&#10;```java&#10;// Main removal logic with host transfer&#10;public boolean removePlayerFromRoom(String roomCode, String playerUuid)&#10;&#10;// Find player who joined right after the host&#10;private Player findNextHost(Room room, LocalDateTime hostJoinedAt)&#10;```&#10;&#10;**Algorithm:**&#10;1. Store host's `joinedAt` before removing player&#10;2. After removal, find player with smallest `joinedAt` &gt; host's `joinedAt`&#10;3. If no such player, wraparound to earliest joined player&#10;4. Set new host flags and update room&#10;&#10;### 2. RoomWebSocketController.java&#10;**Location:** `/src/main/java/com/insidergame/insider_api/websocket/RoomWebSocketController.java`&#10;&#10;**Changes:**&#10;- ✅ Updated `leaveRoom()` - Detect and broadcast host transfer&#10;&#10;**Key Changes:**&#10;```java&#10;// Detect if leaving player was host&#10;boolean wasHost = request.getPlayerUuid().equals(room.getHostUuid());&#10;&#10;// After removal, check if host changed&#10;boolean hostChanged = wasHost &amp;&amp; !room.getHostUuid().equals(oldHostUuid);&#10;&#10;// Broadcast appropriate message&#10;if (hostChanged) {&#10;    broadcastRoomUpdate(roomCode, &quot;HOST_TRANSFERRED&quot;);&#10;} else {&#10;    broadcastRoomUpdate(roomCode, &quot;PLAYER_LEFT&quot;);&#10;}&#10;```&#10;&#10;---&#10;&#10;##  WebSocket Messages&#10;&#10;### New Message Type: HOST_TRANSFERRED&#10;&#10;**Topic:** `/topic/room/{roomCode}`&#10;&#10;**When:** Host leaves and new host is assigned&#10;&#10;**Payload:**&#10;```json&#10;{&#10;  &quot;type&quot;: &quot;HOST_TRANSFERRED&quot;,&#10;  &quot;roomCode&quot;: &quot;ABC123&quot;,&#10;  &quot;roomName&quot;: &quot;Game Room&quot;,&#10;  &quot;maxPlayers&quot;: 8,&#10;  &quot;currentPlayers&quot;: 3,&#10;  &quot;status&quot;: &quot;WAITING&quot;,&#10;  &quot;hostUuid&quot;: &quot;new-host-uuid&quot;,&#10;  &quot;players&quot;: [&#10;    {&#10;      &quot;uuid&quot;: &quot;new-host-uuid&quot;,&#10;      &quot;playerName&quot;: &quot;Bob&quot;,&#10;      &quot;isHost&quot;: true,&#10;      &quot;isReady&quot;: false,&#10;      &quot;isActive&quot;: true&#10;    },&#10;    // ... other players&#10;  ],&#10;  &quot;message&quot;: &quot;HOST_TRANSFERRED&quot;&#10;}&#10;```&#10;&#10;---&#10;&#10;##  Frontend Integration&#10;&#10;### Subscribe to Room Updates&#10;```javascript&#10;stompClient.subscribe(`/topic/room/${roomCode}`, (message) =&gt; {&#10;  const data = JSON.parse(message.body);&#10;  &#10;  switch(data.message) {&#10;    case 'HOST_TRANSFERRED':&#10;      // Old host left, new host assigned&#10;      const newHostUuid = data.hostUuid;&#10;      const newHost = data.players.find(p =&gt; p.isHost);&#10;      &#10;      // Update UI to show new host&#10;      updateHostIndicator(newHost);&#10;      &#10;      // If current user is new host, show host controls&#10;      if (newHostUuid === currentUserUuid) {&#10;        showHostControls();&#10;        showNotification('คุณได้รับตำแหน่งหัวห้อง');&#10;      } else {&#10;        showNotification(`${newHost.playerName} เป็นหัวห้องคนใหม่`);&#10;      }&#10;      break;&#10;      &#10;    case 'PLAYER_LEFT':&#10;      // Regular player left (not host)&#10;      updatePlayerList(data.players);&#10;      break;&#10;      &#10;    case 'ROOM_UPDATE':&#10;      // Room deleted or general update&#10;      updateRoomState(data);&#10;      break;&#10;  }&#10;});&#10;```&#10;&#10;### Example UI Update&#10;```javascript&#10;function updateHostIndicator(newHost) {&#10;  // Remove host badge from all players&#10;  document.querySelectorAll('.host-badge').forEach(badge =&gt; {&#10;    badge.remove();&#10;  });&#10;  &#10;  // Add host badge to new host&#10;  const newHostElement = document.querySelector(`[data-uuid=&quot;${newHost.uuid}&quot;]`);&#10;  if (newHostElement) {&#10;    const badge = document.createElement('span');&#10;    badge.className = 'host-badge';&#10;    badge.textContent = ' Host';&#10;    newHostElement.appendChild(badge);&#10;  }&#10;}&#10;&#10;function showHostControls() {&#10;  // Show host-only buttons&#10;  document.getElementById('start-game-btn').style.display = 'block';&#10;  document.getElementById('delete-room-btn').style.display = 'block';&#10;  document.getElementById('room-settings-btn').style.display = 'block';&#10;}&#10;```&#10;&#10;---&#10;&#10;## ✅ Testing Guide&#10;&#10;### Test Case 1: Basic Host Transfer&#10;**Steps:**&#10;1. Create room (Player A becomes host)&#10;2. Player B joins&#10;3. Player C joins&#10;4. Player A (host) leaves&#10;&#10;**Expected Result:**&#10;- ✅ Player B becomes new host&#10;- ✅ Broadcast message: &quot;HOST_TRANSFERRED&quot;&#10;- ✅ Player B sees host controls&#10;- ✅ UI shows Player B with host badge&#10;&#10;### Test Case 2: Sequential Leaves&#10;**Steps:**&#10;1. Room with 4 players: A (host), B, C, D&#10;2. A leaves → B becomes host&#10;3. B leaves → C becomes host&#10;4. C leaves → D becomes host&#10;5. D leaves → Room deleted&#10;&#10;**Expected Result:**&#10;- ✅ Each transfer follows join order&#10;- ✅ Correct &quot;HOST_TRANSFERRED&quot; broadcasts&#10;- ✅ Room deleted when last player leaves&#10;&#10;### Test Case 3: Wraparound&#10;**Steps:**&#10;1. Player B joins room (first, becomes host)&#10;2. Player A joins room&#10;3. Player B (host) leaves&#10;&#10;**Expected Result:**&#10;- ✅ Player A becomes host (wraparound to earliest)&#10;- ✅ Broadcast &quot;HOST_TRANSFERRED&quot;&#10;&#10;### Test Case 4: Non-Host Leaves&#10;**Steps:**&#10;1. Room with A (host), B, C&#10;2. Player B leaves&#10;&#10;**Expected Result:**&#10;- ✅ Host remains Player A&#10;- ✅ Broadcast message: &quot;PLAYER_LEFT&quot; (not HOST_TRANSFERRED)&#10;- ✅ No host transfer&#10;&#10;### Test Case 5: Multiple Rapid Leaves&#10;**Steps:**&#10;1. Room with 5 players&#10;2. Host leaves immediately&#10;3. New host leaves immediately&#10;4. Continue...&#10;&#10;**Expected Result:**&#10;- ✅ Host transfers correctly in sequence&#10;- ✅ No race conditions&#10;- ✅ Room state always consistent&#10;&#10;### Test Case 6: During Active Game&#10;**Steps:**&#10;1. Start game with 4 players&#10;2. Host leaves during game&#10;&#10;**Expected Result:**&#10;- ✅ Host transfers correctly&#10;- ✅ Game continues (if game logic allows)&#10;- ✅ New host can manage room&#10;&#10;---&#10;&#10;##  Verification Checklist&#10;&#10;### Backend:&#10;- [ ] Host transfer uses `joinedAt` timestamp&#10;- [ ] Next player in join order becomes host&#10;- [ ] Wraparound works when no player joined after host&#10;- [ ] Room deleted when empty&#10;- [ ] Correct WebSocket message sent&#10;- [ ] Logs show host transfer details&#10;&#10;### Frontend:&#10;- [ ] HOST_TRANSFERRED message received&#10;- [ ] UI updates to show new host&#10;- [ ] New host sees host controls&#10;- [ ] Old host controls removed&#10;- [ ] Notification shown to users&#10;- [ ] Player list updated correctly&#10;&#10;### Edge Cases:&#10;- [ ] Works with 2 players&#10;- [ ] Works with max players&#10;- [ ] Handles null joinedAt gracefully&#10;- [ ] No errors when room deleted&#10;- [ ] Works during different room states (WAITING, PLAYING)&#10;&#10;---&#10;&#10;##  Troubleshooting&#10;&#10;### Host not transferred&#10;**Check:**&#10;- Verify `joinedAt` timestamps are set when players join&#10;- Check logs for &quot;Host transferred&quot; message&#10;- Ensure `removePlayerFromRoom()` is called&#10;&#10;### Wrong player becomes host&#10;**Check:**&#10;- Verify `joinedAt` order matches join order&#10;- Check if timestamps are unique (millisecond precision)&#10;- Review `findNextHost()` logic&#10;&#10;### HOST_TRANSFERRED not broadcasted&#10;**Check:**&#10;- Ensure leaving player was actually the host&#10;- Verify WebSocket connection&#10;- Check broadcast logic in `leaveRoom()`&#10;&#10;### Room not deleted when empty&#10;**Check:**&#10;- Verify `room.isEmpty()` returns true&#10;- Check if players are properly removed&#10;- Review `removePlayerFromRoom()` logic&#10;&#10;---&#10;&#10;##  Algorithm Complexity&#10;&#10;### Time Complexity:&#10;- **removePlayerFromRoom:** O(n) where n = number of players&#10;  - Remove player: O(n)&#10;  - Find next host: O(n)&#10;  &#10;- **findNextHost:** O(n)&#10;  - Filter players: O(n)&#10;  - Find minimum: O(n)&#10;&#10;### Space Complexity:&#10;- O(1) - Only temporary variables&#10;&#10;### Performance:&#10;- Efficient for typical room sizes (&lt; 10 players)&#10;- No memory leaks&#10;- Thread-safe (ConcurrentHashMap used in RoomManager)&#10;&#10;---&#10;&#10;##  Future Enhancements&#10;&#10;### Optional Features:&#10;- [ ] Manual host transfer API (host can transfer to anyone)&#10;- [ ] Host transfer vote system&#10;- [ ] Co-host system (multiple hosts)&#10;- [ ] Host transfer history/log&#10;- [ ] Prevent host transfer during critical game moments&#10;&#10;### Configuration:&#10;- [ ] Allow host to set transfer order policy&#10;- [ ] Configurable fallback strategies&#10;- [ ] Auto-promote most active player option&#10;&#10;---&#10;&#10;##  Related Files&#10;&#10;### Core Files:&#10;- `RoomManager.java` - Host transfer logic&#10;- `RoomWebSocketController.java` - WebSocket handling&#10;- `Player.java` - Player model with joinedAt&#10;- `Room.java` - Room model&#10;&#10;### Related Features:&#10;- Player join/leave system&#10;- WebSocket real-time updates&#10;- Room lifecycle management&#10;&#10;---&#10;&#10;## ✨ Status: ✅ COMPLETE&#10;&#10;Feature fully implemented and ready for testing!&#10;&#10;**Key Points:**&#10;- ✅ Host transfers to next player in join order&#10;- ✅ Based on `joinedAt` timestamp&#10;- ✅ Handles all edge cases&#10;- ✅ Broadcasts HOST_TRANSFERRED message&#10;- ✅ Frontend integration ready&#10;- ✅ No compilation errors&#10;&#10;**Implementation Date:** December 1, 2025&#10;**Next Step:** Test with real players! &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HOST_TRANSFER_QUICK.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HOST_TRANSFER_QUICK.md" />
              <option name="updatedContent" value="#  Host Transfer - Quick Reference&#10;&#10;## สรุปสั้นๆ&#10;&#10;### ฟีเจอร์:&#10;เมื่อหัวห้อง leave ออกไป → คนที่เข้ามาล่าสุดต่อจากหัวห้องจะได้รับตำแหน่งหัวห้อง&#10;&#10;### ตัวอย่าง:&#10;```&#10;ลำดับการเข้าห้อง:&#10;1. Alice (Host) &#10;2. Bob&#10;3. Charlie&#10;4. Dave&#10;&#10;Alice leave → Bob เป็นหัวห้องใหม่ &#10;Bob leave → Charlie เป็นหัวห้องใหม่ &#10;Charlie leave → Dave เป็นหัวห้องใหม่ &#10;Dave leave → ห้องถูกลบ ️&#10;```&#10;&#10;---&#10;&#10;##  ไฟล์ที่แก้ไข&#10;&#10;### RoomManager.java&#10;- ✅ `removePlayerFromRoom()` - เพิ่ม logic ถ่ายโอนหัวห้อง&#10;- ✅ `findNextHost()` - หาคนที่เข้ามาต่อจากหัวห้อง&#10;&#10;### RoomWebSocketController.java&#10;- ✅ `leaveRoom()` - ส่ง broadcast &quot;HOST_TRANSFERRED&quot;&#10;&#10;---&#10;&#10;##  WebSocket Message&#10;&#10;### ข้อความใหม่: HOST_TRANSFERRED&#10;```json&#10;{&#10;  &quot;message&quot;: &quot;HOST_TRANSFERRED&quot;,&#10;  &quot;roomCode&quot;: &quot;ABC123&quot;,&#10;  &quot;hostUuid&quot;: &quot;new-host-uuid&quot;,&#10;  &quot;players&quot;: [...]&#10;}&#10;```&#10;&#10;---&#10;&#10;##  ทดสอบง่ายๆ&#10;&#10;### Test 1: ถ่ายโอนพื้นฐาน&#10;```&#10;1. สร้างห้อง (A เป็น host)&#10;2. B เข้าห้อง&#10;3. A leave&#10;→ คาดหวัง: B เป็น host ✅&#10;```&#10;&#10;### Test 2: ถ่ายโอนต่อเนื่อง&#10;```&#10;1. ห้องมี A, B, C, D&#10;2. A leave → B เป็น host&#10;3. B leave → C เป็น host&#10;4. C leave → D เป็น host&#10;5. D leave → ห้องถูกลบ&#10;→ คาดหวัง: ถ่ายโอนถูกต้องทุกครั้ง ✅&#10;```&#10;&#10;### Test 3: คนธรรมดา leave&#10;```&#10;1. ห้องมี A (host), B, C&#10;2. B leave&#10;→ คาดหวัง: A ยังเป็น host, ไม่มีการถ่ายโอน ✅&#10;```&#10;&#10;---&#10;&#10;##  Frontend Code&#10;&#10;```javascript&#10;stompClient.subscribe(`/topic/room/${roomCode}`, (msg) =&gt; {&#10;  const data = JSON.parse(msg.body);&#10;  &#10;  if (data.message === 'HOST_TRANSFERRED') {&#10;    const newHost = data.players.find(p =&gt; p.isHost);&#10;    &#10;    // อัพเดต UI&#10;    updateHostBadge(newHost);&#10;    &#10;    // ถ้าเราเป็น host คนใหม่&#10;    if (data.hostUuid === myUuid) {&#10;      showHostControls();&#10;      alert('คุณเป็นหัวห้องคนใหม่! ');&#10;    }&#10;  }&#10;});&#10;```&#10;&#10;---&#10;&#10;## ✅ สถานะ: พร้อมใช้งาน!&#10;&#10;- ✅ ใช้ `joinedAt` timestamp&#10;- ✅ หาคนที่เข้ามาต่อจาก host&#10;- ✅ จัดการ edge cases ทั้งหมด&#10;- ✅ ส่ง broadcast message&#10;- ✅ ไม่มี error&#10;&#10;---&#10;&#10;##  เอกสารเพิ่มเติม&#10;&#10;ดูรายละเอียดเต็มที่: **HOST_TRANSFER_FEATURE.md**&#10;&#10;---&#10;&#10;**Status:** ✅ Complete&#10;**Ready to test!** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/VOTE_FIX_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/VOTE_FIX_SUMMARY.md" />
              <option name="updatedContent" value="# Fix: activeGame.votes Not Showing After Player Vote&#10;&#10;## Problem&#10;After calling `playerVote()`, the `activeGame` field `votes` was not visible in the frontend.&#10;&#10;## Root Causes&#10;&#10;### 1. **Backend**: Votes field was missing from active_game response&#10;The `currentGame()` handler in `RoomWebSocketController` was not including the `votes` field when building the gameMap response.&#10;&#10;### 2. **Frontend**: No request for updated activeGame after voting&#10;The `playerVote()` function was sending the vote but not requesting the updated active game data to see the votes.&#10;&#10;### 3. **Frontend**: Missing VOTE_CAST trigger&#10;The room update subscription wasn't listening for `VOTE_CAST` events to trigger an active game refresh.&#10;&#10;## Solution&#10;&#10;### Backend Fix ✅&#10;**File**: `RoomWebSocketController.java`&#10;&#10;Added `votes` field to the active_game response payload:&#10;&#10;```java&#10;gameMap.put(&quot;votes&quot;, g.getVotes());&#10;```&#10;&#10;Now when clients request `/app/room/{roomCode}/active_game`, they receive:&#10;```json&#10;{&#10;  &quot;game&quot;: {&#10;    &quot;id&quot;: &quot;...&quot;,&#10;    &quot;votes&quot;: {&#10;      &quot;player-uuid-1&quot;: &quot;target-uuid-a&quot;,&#10;      &quot;player-uuid-2&quot;: &quot;target-uuid-b&quot;&#10;    },&#10;    &quot;cardOpened&quot;: {...},&#10;    ...&#10;  }&#10;}&#10;```&#10;&#10;### Frontend Fix ✅&#10;**File**: `useRoomWebSocket.ts` (or `useRoomWebSocket_updated.ts`)&#10;&#10;#### 1. Added VOTE_CAST listener&#10;```typescript&#10;if (&#10;  update.type === &quot;CARD_OPENED&quot; ||&#10;  update.type === &quot;GAME_STARTED&quot; ||&#10;  update.type === &quot;VOTE_CAST&quot; ||      // ← NEW&#10;  update.type === &quot;VOTE_STARTED&quot; ||   // ← NEW&#10;  (update.activeGame !== undefined &amp;&amp; update.activeGame !== null)&#10;) {&#10;  // Request updated active game&#10;  clientRef.current.publish({&#10;    destination: `/app/room/${roomCode}/active_game`,&#10;    body: JSON.stringify({ playerUuid }),&#10;  });&#10;}&#10;```&#10;&#10;#### 2. Auto-request after voting&#10;```typescript&#10;const playerVote = useCallback(&#10;  (targetPlayerUuid: string) =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      // Send vote&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/vote`,&#10;        body: JSON.stringify({ playerUuid, targetPlayerUuid }),&#10;      });&#10;      &#10;      // Immediately request active game to see updated votes&#10;      setTimeout(() =&gt; {&#10;        if (clientRef.current?.connected) {&#10;          clientRef.current.publish({&#10;            destination: `/app/room/${roomCode}/active_game`,&#10;            body: JSON.stringify({ playerUuid }),&#10;          });&#10;        }&#10;      }, 100);&#10;    }&#10;  },&#10;  [roomCode, playerUuid, isConnected]&#10;);&#10;```&#10;&#10;## How It Works Now&#10;&#10;### Flow:&#10;1. **Player clicks vote** → `playerVote(targetUuid)` called&#10;2. **Vote sent** → Server receives at `/app/room/{roomCode}/vote`&#10;3. **Server updates** → `GameManager.recordVote()` stores vote in `Game.votes` map&#10;4. **Server broadcasts** → `VOTE_CAST` message to `/topic/room/{roomCode}`&#10;5. **Frontend receives** → `VOTE_CAST` in room subscription&#10;6. **Frontend requests** → `/app/room/{roomCode}/active_game`&#10;7. **Server responds** → `/user/queue/active_game` with updated votes field&#10;8. **Frontend updates** → `setActiveGame(game)` with votes visible&#10;&#10;### Result:&#10;```typescript&#10;activeGame.votes = {&#10;  &quot;uuid-player-1&quot;: &quot;uuid-target-a&quot;,&#10;  &quot;uuid-player-2&quot;: &quot;uuid-target-b&quot;,&#10;  &quot;uuid-player-3&quot;: &quot;uuid-target-a&quot;&#10;}&#10;```&#10;&#10;## Testing&#10;1. Start a game with multiple players&#10;2. Trigger voting phase (master_end)&#10;3. Each player calls `playerVote(targetUuid)`&#10;4. Check browser console for:&#10;   - `️ Player is voting for: [uuid]`&#10;   - `Room update received: { type: &quot;VOTE_CAST&quot; }`&#10;   - ` Requesting active game after vote...`&#10;   - ` active_game (user queue) received: { votes: {...} }`&#10;5. Verify `activeGame.votes` object in React state contains all votes&#10;&#10;## Additional Notes&#10;- Votes can be changed (new vote overwrites previous vote from same voter)&#10;- Only participants (players with roles) can vote&#10;- The `votes` map is initialized as empty `{}` when game is created&#10;- Votes persist across reconnects (stored in server memory via GameManager)&#10;&#10;## Files Modified&#10;1. `/src/main/java/com/insidergame/insider_api/websocket/RoomWebSocketController.java`&#10;2. `/hooks/useRoomWebSocket.ts` (create updated version as `useRoomWebSocket_updated.ts`)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/enums/RoomStatus.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/enums/RoomStatus.java" />
              <option name="originalContent" value="package com.insidergame.insider_api.enums;&#10;&#10;public enum RoomStatus {&#10;    WAITING ,&#10;    PLAYING,&#10;}&#10;" />
              <option name="updatedContent" value="package com.insidergame.insider_api.enums;&#10;&#10;public enum RoomStatus {&#10;    WAITING ,&#10;    PLAYING,&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>