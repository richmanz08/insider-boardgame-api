<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/hooks/useRoomWebSocket.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hooks/useRoomWebSocket.ts" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import { useEffect, useRef, useState, useCallback } from &quot;react&quot;;&#10;import SockJS from &quot;sockjs-client&quot;;&#10;import { Client, IMessage } from &quot;@stomp/stompjs&quot;;&#10;import {&#10;  PlayerData,&#10;  RoomUpdateMessage,&#10;  GamePrivateMessage,&#10;  ActiveGame,&#10;} from &quot;./interface&quot;;&#10;&#10;const WS_URL = process.env.NEXT_PUBLIC_WS_URL || &quot;http://localhost:8080/ws&quot;;&#10;&#10;export function useRoomWebSocket(roomCode: string, playerUuid: string) {&#10;  const clientRef = useRef&lt;Client | null&gt;(null);&#10;  const [players, setPlayers] = useState&lt;PlayerData[]&gt;([]);&#10;  const [isConnected, setIsConnected] = useState(false);&#10;  const [lastUpdate, setLastUpdate] = useState&lt;RoomUpdateMessage | null&gt;(null);&#10;  const [gamePrivateInfo, setGamePrivateInfo] =&#10;    useState&lt;GamePrivateMessage | null&gt;(null);&#10;&#10;  // NEW: activeGame snapshot (may contain cardOpened map)&#10;  const [activeGame, setActiveGame] = useState&lt;ActiveGame | null&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    const client = new Client({&#10;      webSocketFactory: () =&gt; new SockJS(WS_URL),&#10;      reconnectDelay: 5000,&#10;      heartbeatIncoming: 4000,&#10;      heartbeatOutgoing: 4000,&#10;    });&#10;&#10;    client.onConnect = () =&gt; {&#10;      setIsConnected(true);&#10;&#10;      // Subscribe to room updates&#10;      client.subscribe(`/topic/room/${roomCode}`, (message: IMessage) =&gt; {&#10;        const update: RoomUpdateMessage = JSON.parse(message.body);&#10;        console.log(&quot;Room update received:&quot;, update);&#10;&#10;        setLastUpdate(update);&#10;        setPlayers(update.players);&#10;&#10;        // If server included activeGame in the broadcast, use it directly (contains cardOpened)&#10;        if (update.activeGame) {&#10;          try {&#10;            setActiveGame(update.activeGame as ActiveGame);&#10;          } catch (e) {&#10;            // fallback: request per-session snapshot&#10;            if (clientRef.current?.connected &amp;&amp; playerUuid) {&#10;              clientRef.current.publish({&#10;                destination: `/app/room/${roomCode}/active_game`,&#10;                body: JSON.stringify({ playerUuid }),&#10;              });&#10;            }&#10;          }&#10;        } else if (update.type === &quot;CARD_OPENED&quot; || update.type === &quot;GAME_STARTED&quot;) {&#10;          // broadcast didn't include activeGame; request per-session snapshot&#10;          if (clientRef.current?.connected &amp;&amp; playerUuid) {&#10;            clientRef.current.publish({&#10;              destination: `/app/room/${roomCode}/active_game`,&#10;              body: JSON.stringify({ playerUuid }),&#10;            });&#10;          }&#10;        }&#10;      });&#10;&#10;      // Subscribe to per-user active_game response (server sends to /user/queue/active_game)&#10;      client.subscribe(&quot;/user/queue/active_game&quot;, (message: IMessage) =&gt; {&#10;        try {&#10;          const payload = JSON.parse(message.body);&#10;          // server might send either { game: {...} } or direct Game object&#10;          const game = payload &amp;&amp; payload.game ? payload.game : payload;&#10;          console.log(&quot;active_game (user queue) received:&quot;, game);&#10;          setActiveGame(game);&#10;        } catch (err) {&#10;          console.error(&quot;Failed parse active_game response:&quot;, err);&#10;        }&#10;      });&#10;&#10;      // Subscribe to game private messages (role &amp; word for MASTER/INSIDER)&#10;      client.subscribe(`/user/queue/game_private`, (message: IMessage) =&gt; {&#10;        const privateInfo: GamePrivateMessage = JSON.parse(message.body);&#10;        console.log(&quot;Game private info received:&quot;, privateInfo);&#10;        setGamePrivateInfo(privateInfo);&#10;      });&#10;&#10;      // join&#10;      client.publish({&#10;        destination: `/app/room/${roomCode}/join`,&#10;        body: JSON.stringify({&#10;          playerUuid,&#10;          active: true,&#10;        }),&#10;      });&#10;&#10;      // sync visibility after join&#10;      setTimeout(() =&gt; {&#10;        const isVisible = document.visibilityState === &quot;visible&quot;;&#10;        if (!isVisible &amp;&amp; clientRef.current?.connected) {&#10;          clientRef.current.publish({&#10;            destination: `/app/room/${roomCode}/status`,&#10;            body: JSON.stringify({&#10;              playerUuid,&#10;              active: false,&#10;            }),&#10;          });&#10;        }&#10;      }, 500);&#10;    };&#10;&#10;    client.onDisconnect = () =&gt; {&#10;      setIsConnected(false);&#10;    };&#10;&#10;    client.onStompError = (frame) =&gt; {&#10;      console.error(&quot;WebSocket error:&quot;, frame);&#10;    };&#10;&#10;    client.activate();&#10;    clientRef.current = client;&#10;&#10;    const handleVisibilityChange = () =&gt; {&#10;      const isVisible = document.visibilityState === &quot;visible&quot;;&#10;      if (clientRef.current?.connected &amp;&amp; playerUuid) {&#10;        clientRef.current.publish({&#10;          destination: `/app/room/${roomCode}/status`,&#10;          body: JSON.stringify({&#10;            playerUuid,&#10;            active: isVisible,&#10;          }),&#10;        });&#10;      }&#10;    };&#10;    document.addEventListener(&quot;visibilitychange&quot;, handleVisibilityChange);&#10;&#10;    return () =&gt; {&#10;      document.removeEventListener(&quot;visibilitychange&quot;, handleVisibilityChange);&#10;      if (clientRef.current?.connected &amp;&amp; playerUuid) {&#10;        try {&#10;          clientRef.current.publish({&#10;            destination: `/app/room/${roomCode}/leave`,&#10;            body: JSON.stringify({ playerUuid }),&#10;          });&#10;        } catch (error) {&#10;          console.error(&quot;Error sending leave message:&quot;, error);&#10;        }&#10;      }&#10;      clientRef.current?.deactivate();&#10;    };&#10;  }, [roomCode, playerUuid]);&#10;&#10;  // Toggle ready&#10;  const toggleReady = useCallback(() =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/ready`,&#10;        body: JSON.stringify({ playerUuid }),&#10;      });&#10;    }&#10;  }, [roomCode, playerUuid, isConnected]);&#10;&#10;  // Start game (host)&#10;  const startGame = useCallback(() =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/start`,&#10;        body: JSON.stringify({ triggerByUuid: playerUuid }),&#10;      });&#10;    }&#10;  }, [roomCode, playerUuid, isConnected]);&#10;&#10;  // Handle card opened (user action)&#10;  const handleCardOpened = useCallback(() =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/open_card`,&#10;        body: JSON.stringify({ playerUuid }),&#10;      });&#10;&#10;      // Optionally also request snapshot immediately (redundant if server broadcasts CARD_OPENED)&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/active_game`,&#10;        body: JSON.stringify({ playerUuid }),&#10;      });&#10;    }&#10;  }, [roomCode, playerUuid, isConnected]);&#10;&#10;  return {&#10;    players,&#10;    isConnected,&#10;    lastUpdate,&#10;    activeGame, // NEW: the per-user active game snapshot (may contain cardOpened map)&#10;    gamePrivateInfo,&#10;    toggleReady,&#10;    startGame,&#10;    handleCardOpened,&#10;  };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>