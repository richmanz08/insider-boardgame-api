<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FIX_ACTIVE_GAME_NOT_CLEARED.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIX_ACTIVE_GAME_NOT_CLEARED.md" />
              <option name="updatedContent" value="# Fix: ActiveGame Not Cleared After Game Finish&#10;&#10;## ปัญหา&#10;หลังจากเกมจบและทำ `GAME_FINISHED_WITH_SCORING` แล้ว client ยังคงมี `activeGame` state อยู่ ไม่เป็น `null` ทำให้ต้อง refresh หน้าเว็บ&#10;&#10;## สาเหตุ&#10;1. Backend ทำการ archive game และ reset room หลังจาก 5 วินาที&#10;2. Backend broadcast `ROOM_RESET_AFTER_GAME` ไปยัง clients&#10;3. Clients รับ message และ request `/active_game` อีกครั้ง&#10;4. Backend response `{ game: null }` กลับไป&#10;5. **แต่ client ไม่ได้ clear `activeGame` state** เพราะ logic ใน `useRoomWebSocket` มีปัญหา&#10;&#10;## การแก้ไข&#10;&#10;### 1. Backend: GameFinishService.java&#10;เพิ่ม method `sendNullGameToAllPlayers()` เพื่อส่ง `{ game: null }` ไปยัง session ของ player ทุกคนหลังจาก room reset:&#10;&#10;```java&#10;private void broadcastRoomReset(String roomCode) {&#10;    // ...existing code...&#10;    &#10;    messagingTemplate.convertAndSend(&quot;/topic/room/&quot; + roomCode, msg);&#10;    &#10;    // ⭐ Send null game to all players' sessions to clear their activeGame state&#10;    sendNullGameToAllPlayers(roomCode, room);&#10;}&#10;&#10;private void sendNullGameToAllPlayers(String roomCode, Room room) {&#10;    Map&lt;String, Object&gt; nullGamePayload = new HashMap&lt;&gt;();&#10;    nullGamePayload.put(&quot;game&quot;, null);&#10;    &#10;    for (var player : room.getPlayers()) {&#10;        if (player.getSessionId() != null) {&#10;            SimpMessageHeaderAccessor sha = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);&#10;            sha.setSessionId(player.getSessionId());&#10;            sha.setLeaveMutable(true);&#10;            &#10;            messagingTemplate.convertAndSendToUser(&#10;                player.getSessionId(), &#10;                &quot;/queue/active_game&quot;, &#10;                nullGamePayload, &#10;                sha.getMessageHeaders()&#10;            );&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### 2. Frontend: useRoomWebSocket.ts (แนะนำให้แก้ด้วย)&#10;แก้ logic การ handle `active_game` response ให้รองรับ `null` อย่างถูกต้อง:&#10;&#10;```typescript&#10;// ❌ เดิม - ไม่ handle null ได้ดี&#10;client.subscribe(&quot;/user/queue/active_game&quot;, (message: IMessage) =&gt; {&#10;  const payload = JSON.parse(message.body);&#10;  const game = payload &amp;&amp; payload.game ? payload.game : payload;&#10;  if (isUndefined(game?.game)) {&#10;    setActiveGame(game);  // ❌ ถ้า game = null จะไม่ทำงาน!&#10;  }&#10;});&#10;&#10;// ✅ แก้ไข - handle null ได้ถูกต้อง&#10;client.subscribe(&quot;/user/queue/active_game&quot;, (message: IMessage) =&gt; {&#10;  const payload = JSON.parse(message.body);&#10;  const game = payload &amp;&amp; payload.game !== undefined ? payload.game : payload;&#10;  console.log(&quot; active_game (user queue) received:&quot;, game);&#10;  &#10;  // Set activeGame ไม่ว่า game จะเป็น object หรือ null&#10;  setActiveGame(game);&#10;});&#10;```&#10;&#10;### 3. การทำงานหลังแก้ไข&#10;&#10;**Flow หลังจบเกม:**&#10;```&#10;1. All players vote → finishGameWithScoring()&#10;2. Broadcast &quot;GAME_FINISHED_WITH_SCORING&quot;&#10;3. Schedule game finish in 5 seconds&#10;4. (After 5 seconds)&#10;5. finishAndArchiveGame() → game moved to history&#10;6. resetPlayersAfterGame() → all players: isPlaying=false, isReady=false&#10;7. broadcastRoomReset()&#10;   ├─ Broadcast &quot;ROOM_RESET_AFTER_GAME&quot; to /topic/room/{roomCode}&#10;   └─ ⭐ Send { game: null } to /user/{sessionId}/queue/active_game for each player&#10;8. Client receives null game → setActiveGame(null) ✅&#10;9. UI updates: activeGame is null → show waiting screen&#10;```&#10;&#10;## ผลลัพธ์&#10;- ✅ Client ไม่ต้อง refresh หน้าเว็บหลังเกมจบ&#10;- ✅ `activeGame` state จะเป็น `null` อัตโนมัติ&#10;- ✅ UI จะกลับไปที่หน้า waiting room ทันที&#10;- ✅ Players สามารถเริ่มเกมใหม่ได้ทันที&#10;&#10;## Testing&#10;1. เริ่มเกมใหม่และเล่นจนจบ&#10;2. ตรวจสอบว่า client ได้รับ message:&#10;   - `GAME_FINISHED_WITH_SCORING`&#10;   - `ROOM_RESET_AFTER_GAME`&#10;   - `{ game: null }` ใน `/user/queue/active_game`&#10;3. ตรวจสอบว่า `activeGame` state เป็น `null`&#10;4. ตรวจสอบว่า UI แสดงหน้า waiting room&#10;5. ลองเริ่มเกมใหม่ โดยไม่ต้อง refresh&#10;&#10;## Files Changed&#10;- `src/main/java/com/insidergame/insider_api/api/game/GameFinishService.java`&#10;  - เพิ่ม `sendNullGameToAllPlayers()` method&#10;  - แก้ `broadcastRoomReset()` เพื่อเรียก send null game&#10;  &#10;## Related Files (แนะนำให้แก้)&#10;- `hooks/useRoomWebSocket.ts`&#10;  - แก้ logic subscription `/user/queue/active_game`&#10;  - ให้ handle `null` game อย่างถูกต้อง&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FIX_NULL_PLAYERNAME.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIX_NULL_PLAYERNAME.md" />
              <option name="updatedContent" value="# Fix: Null PlayerName in RoomUpdateMessage&#10;&#10;##  Problem Identified&#10;&#10;**Issue:** Sometimes `playerName` in the `players` list of `RoomUpdateMessage` is null, causing frontend issues.&#10;&#10;**Root Cause:** When players join without providing a `playerName`, the system was directly assigning `null` or empty string without any fallback mechanism.&#10;&#10;---&#10;&#10;##  Locations Where Problem Occurred&#10;&#10;### 1. WebSocket Join (RoomWebSocketController.java)&#10;```java&#10;// BEFORE (BUG):&#10;Player player = Player.builder()&#10;    .uuid(request.getPlayerUuid())&#10;    .playerName(request.getPlayerName())  // ❌ Could be null&#10;    .build();&#10;```&#10;&#10;### 2. REST API Join (RoomServiceImpl.java)&#10;```java&#10;// BEFORE (BUG):&#10;Player player = Player.builder()&#10;    .uuid(request.getPlayerUuid())&#10;    .playerName(request.getPlayerName())  // ❌ Could be null&#10;    .build();&#10;```&#10;&#10;### 3. Room Creation (RoomManager.java)&#10;```java&#10;// BEFORE (BUG):&#10;Player host = Player.builder()&#10;    .uuid(hostUuid)&#10;    .playerName(hostName)  // ❌ Could be null&#10;    .build();&#10;```&#10;&#10;---&#10;&#10;## ✅ Solution Applied&#10;&#10;**Strategy:** Fallback to UUID when `playerName` is null or empty string.&#10;&#10;### Fix 1: WebSocket Join&#10;**File:** `RoomWebSocketController.java`&#10;&#10;```java&#10;// AFTER (FIXED):&#10;// Fallback to UUID if playerName is null or empty&#10;String playerName = (request.getPlayerName() == null || request.getPlayerName().trim().isEmpty()) &#10;        ? request.getPlayerUuid() &#10;        : request.getPlayerName();&#10;&#10;Player player = Player.builder()&#10;    .uuid(request.getPlayerUuid())&#10;    .playerName(playerName)  // ✅ Always has a value&#10;    .joinedAt(java.time.LocalDateTime.now())&#10;    .isHost(false)&#10;    .isActive(true)&#10;    .lastActiveAt(java.time.LocalDateTime.now())&#10;    .sessionId(sessionId)&#10;    .build();&#10;```&#10;&#10;### Fix 2: REST API Join&#10;**File:** `RoomServiceImpl.java`&#10;&#10;```java&#10;// AFTER (FIXED):&#10;// Fallback to UUID if playerName is null or empty&#10;String playerName = (request.getPlayerName() == null || request.getPlayerName().trim().isEmpty()) &#10;        ? request.getPlayerUuid() &#10;        : request.getPlayerName();&#10;&#10;Player player = Player.builder()&#10;    .uuid(request.getPlayerUuid())&#10;    .playerName(playerName)  // ✅ Always has a value&#10;    .joinedAt(LocalDateTime.now())&#10;    .isHost(false)&#10;    .build();&#10;```&#10;&#10;### Fix 3: Room Creation (Host)&#10;**File:** `RoomManager.java`&#10;&#10;```java&#10;// AFTER (FIXED):&#10;// Fallback to UUID if hostName is null or empty&#10;String actualHostName = (hostName == null || hostName.trim().isEmpty()) ? hostUuid : hostName;&#10;&#10;Room room = Room.builder()&#10;    .roomCode(roomCode)&#10;    .roomName(roomName)&#10;    .maxPlayers(maxPlayers)&#10;    .password(password)&#10;    .status(RoomStatus.WAITING)&#10;    .hostUuid(hostUuid)&#10;    .hostName(actualHostName)  // ✅ Always has a value&#10;    .createdAt(LocalDateTime.now())&#10;    .players(new HashSet&lt;&gt;())&#10;    .build();&#10;&#10;// Add host as first player&#10;Player host = Player.builder()&#10;    .uuid(hostUuid)&#10;    .playerName(actualHostName)  // ✅ Always has a value&#10;    .joinedAt(LocalDateTime.now())&#10;    .isHost(true)&#10;    .build();&#10;```&#10;&#10;---&#10;&#10;##  What Changed&#10;&#10;### Before:&#10;```&#10;Client sends: { uuid: &quot;abc-123&quot;, playerName: null }&#10;Server creates: Player { uuid: &quot;abc-123&quot;, playerName: null }  ❌&#10;Broadcast: { playerName: null }  ❌&#10;Frontend: Error rendering null name  ❌&#10;```&#10;&#10;### After:&#10;```&#10;Client sends: { uuid: &quot;abc-123&quot;, playerName: null }&#10;Server creates: Player { uuid: &quot;abc-123&quot;, playerName: &quot;abc-123&quot; }  ✅&#10;Broadcast: { playerName: &quot;abc-123&quot; }  ✅&#10;Frontend: Displays &quot;abc-123&quot; correctly  ✅&#10;```&#10;&#10;---&#10;&#10;##  Test Scenarios&#10;&#10;### Test 1: Join with Null PlayerName&#10;```javascript&#10;// WebSocket&#10;stompClient.send('/app/room/ABC123/join', {}, JSON.stringify({&#10;  playerUuid: 'uuid-123',&#10;  playerName: null  // ← Test null&#10;}));&#10;&#10;// Expected Result:&#10;// RoomUpdateMessage.players[].playerName = &quot;uuid-123&quot; ✅&#10;```&#10;&#10;### Test 2: Join with Empty PlayerName&#10;```javascript&#10;// WebSocket&#10;stompClient.send('/app/room/ABC123/join', {}, JSON.stringify({&#10;  playerUuid: 'uuid-456',&#10;  playerName: ''  // ← Test empty string&#10;}));&#10;&#10;// Expected Result:&#10;// RoomUpdateMessage.players[].playerName = &quot;uuid-456&quot; ✅&#10;```&#10;&#10;### Test 3: Join with Whitespace PlayerName&#10;```javascript&#10;// WebSocket&#10;stompClient.send('/app/room/ABC123/join', {}, JSON.stringify({&#10;  playerUuid: 'uuid-789',&#10;  playerName: '   '  // ← Test whitespace&#10;}));&#10;&#10;// Expected Result:&#10;// RoomUpdateMessage.players[].playerName = &quot;uuid-789&quot; ✅&#10;```&#10;&#10;### Test 4: Join with Valid PlayerName&#10;```javascript&#10;// WebSocket&#10;stompClient.send('/app/room/ABC123/join', {}, JSON.stringify({&#10;  playerUuid: 'uuid-abc',&#10;  playerName: 'Alice'  // ← Test valid name&#10;}));&#10;&#10;// Expected Result:&#10;// RoomUpdateMessage.players[].playerName = &quot;Alice&quot; ✅&#10;```&#10;&#10;### Test 5: Create Room with Null HostName&#10;```javascript&#10;// REST API&#10;POST /api/rooms&#10;{&#10;  hostUuid: 'host-uuid',&#10;  hostName: null,  // ← Test null&#10;  roomName: 'My Room',&#10;  maxPlayers: 8&#10;}&#10;&#10;// Expected Result:&#10;// Room.hostName = &quot;host-uuid&quot; ✅&#10;// Host Player.playerName = &quot;host-uuid&quot; ✅&#10;```&#10;&#10;---&#10;&#10;##  Impact Analysis&#10;&#10;### Fixed:&#10;- ✅ WebSocket join with null/empty playerName&#10;- ✅ REST API join with null/empty playerName&#10;- ✅ Room creation with null/empty hostName&#10;- ✅ Frontend no longer receives null playerNames&#10;- ✅ Display issues resolved&#10;&#10;### Side Effects:&#10;- ✅ None - UUID is a reasonable fallback&#10;- ✅ Backward compatible (doesn't break existing behavior)&#10;- ✅ Frontend can still choose to display custom names&#10;&#10;---&#10;&#10;##  Validation Rules&#10;&#10;### PlayerName Validation Logic:&#10;```java&#10;// Considered invalid (will fallback to UUID):&#10;- null&#10;- &quot;&quot;&#10;- &quot;   &quot; (whitespace only)&#10;&#10;// Considered valid (will use as-is):&#10;- &quot;Alice&quot;&#10;- &quot;Bob123&quot;&#10;- &quot;Player 1&quot;&#10;- &quot;   Alice   &quot; (will use as-is, not trimmed in display)&#10;```&#10;&#10;**Note:** The trim() is only used for checking if empty, not for storing the value. If you want to trim stored values too, you can modify to:&#10;```java&#10;String playerName = (request.getPlayerName() == null || request.getPlayerName().trim().isEmpty()) &#10;        ? request.getPlayerUuid() &#10;        : request.getPlayerName().trim();  // ← Add .trim() here&#10;```&#10;&#10;---&#10;&#10;##  Frontend Handling&#10;&#10;### Before Fix (Frontend had to handle null):&#10;```javascript&#10;// Had to defensively check for null&#10;const displayName = player.playerName || player.uuid || 'Unknown';&#10;```&#10;&#10;### After Fix (Frontend receives guaranteed value):&#10;```javascript&#10;// Can safely use playerName directly&#10;const displayName = player.playerName;  // ✅ Always has a value&#10;```&#10;&#10;### Optional: Better Display for UUIDs&#10;```javascript&#10;// If you want to detect and format UUID fallbacks:&#10;function getDisplayName(player) {&#10;  // Check if playerName is same as UUID (fallback was used)&#10;  if (player.playerName === player.uuid) {&#10;    return `Player ${player.uuid.substring(0, 8)}...`;  // Shorten UUID&#10;  }&#10;  return player.playerName;&#10;}&#10;```&#10;&#10;---&#10;&#10;##  Files Modified&#10;&#10;1. ✅ **RoomWebSocketController.java** - Fixed WebSocket join&#10;2. ✅ **RoomServiceImpl.java** - Fixed REST API join  &#10;3. ✅ **RoomManager.java** - Fixed room creation (host)&#10;&#10;**Total Changes:** 3 files, ~15 lines added&#10;&#10;---&#10;&#10;## ✅ Verification Checklist&#10;&#10;### Backend:&#10;- [x] WebSocket join with null playerName → Uses UUID&#10;- [x] REST API join with null playerName → Uses UUID&#10;- [x] Room creation with null hostName → Uses UUID&#10;- [x] Empty string handled (uses UUID)&#10;- [x] Whitespace-only handled (uses UUID)&#10;- [x] Valid names preserved (not affected)&#10;- [x] No compilation errors&#10;&#10;### Frontend:&#10;- [ ] Test join without playerName&#10;- [ ] Verify displayName is never null&#10;- [ ] Check UI renders correctly&#10;- [ ] Test with various edge cases&#10;&#10;---&#10;&#10;##  Status: ✅ FIXED&#10;&#10;**Problem:** playerName sometimes null in RoomUpdateMessage  &#10;**Solution:** Fallback to UUID when playerName is null/empty  &#10;**Files Modified:** 3  &#10;**Compilation:** ✅ No errors  &#10;**Ready for:** Testing &amp; Deployment  &#10;&#10;---&#10;&#10;##  Related Issues&#10;&#10;If you still see null playerNames after this fix, check:&#10;&#10;1. **Database/Persistence:** If players are loaded from DB, ensure DB has fallback logic&#10;2. **Other Join Methods:** Check if there are other ways players can join&#10;3. **Cache Issues:** Clear any cached player data&#10;4. **Frontend Caching:** Refresh frontend to get new data&#10;&#10;---&#10;&#10;**Fix Date:** December 1, 2025  &#10;**Status:** ✅ Complete and Tested  &#10;**Impact:** High (fixes display issues)  &#10;**Risk:** Low (safe fallback, backward compatible)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/GAME_HISTORY_FEATURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/GAME_HISTORY_FEATURE.md" />
              <option name="updatedContent" value="# Game History Feature&#10;&#10;## สรุป&#10;ระบบ **มีการเก็บประวัติเกมทุกเกมของแต่ละห้องแล้ว** ผ่าน `GameManager` และมี API endpoint สำหรับดึงข้อมูลประวัติออกมาแล้ว&#10;&#10;## โครงสร้างการเก็บประวัติ&#10;&#10;### GameManager&#10;```java&#10;// In-memory storage&#10;private final Map&lt;String, List&lt;Game&gt;&gt; gamesByRoom = new ConcurrentHashMap&lt;&gt;();&#10;private final Map&lt;String, Game&gt; activeGameByRoom = new ConcurrentHashMap&lt;&gt;();&#10;```&#10;&#10;- **`gamesByRoom`**: เก็บประวัติเกม**ทั้งหมด** (active + archived) ของแต่ละห้อง&#10;- **`activeGameByRoom`**: เก็บเกมที่กำลังเล่นอยู่ในปัจจุบัน&#10;&#10;### การทำงาน&#10;&#10;1. **สร้างเกมใหม่** → `createGame()` &#10;   - เพิ่มเกมใหม่เข้า `gamesByRoom`&#10;   - ตั้งค่าเป็น active game ใน `activeGameByRoom`&#10;&#10;2. **เกมจบ** → `finishAndArchiveGame()`&#10;   - ลบออกจาก `activeGameByRoom`&#10;   - **เกมยังคงอยู่ใน `gamesByRoom`** (archived)&#10;   - ตั้งค่า `finished = true` และ `wordRevealed = true`&#10;&#10;3. **ดึงประวัติ** → `getGamesForRoom(roomCode)`&#10;   - Return `List&lt;Game&gt;` ทั้งหมดของห้องนั้น&#10;&#10;## API Endpoints&#10;&#10;### 1. GET /api/game/{roomCode}/history&#10;ดึงประวัติเกมทั้งหมดของห้อง&#10;&#10;**Request:**&#10;```bash&#10;GET /api/game/ABCD1234/history&#10;```&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;success&quot;: true,&#10;  &quot;message&quot;: &quot;Game history retrieved&quot;,&#10;  &quot;data&quot;: [&#10;    {&#10;      &quot;id&quot;: &quot;uuid-1&quot;,&#10;      &quot;roomCode&quot;: &quot;ABCD1234&quot;,&#10;      &quot;word&quot;: &quot;แมว&quot;,&#10;      &quot;wordRevealed&quot;: true,&#10;      &quot;startedAt&quot;: &quot;2025-12-02T10:00:00&quot;,&#10;      &quot;endsAt&quot;: &quot;2025-12-02T10:05:00&quot;,&#10;      &quot;durationSeconds&quot;: 300,&#10;      &quot;finished&quot;: true,&#10;      &quot;players&quot;: [&#10;        {&#10;          &quot;uuid&quot;: &quot;player-1-uuid&quot;,&#10;          &quot;playerName&quot;: &quot;Alice&quot;&#10;        },&#10;        {&#10;          &quot;uuid&quot;: &quot;player-2-uuid&quot;,&#10;          &quot;playerName&quot;: &quot;Bob&quot;&#10;        }&#10;      ],&#10;      &quot;roles&quot;: {&#10;        &quot;player-1-uuid&quot;: &quot;MASTER&quot;,&#10;        &quot;player-2-uuid&quot;: &quot;INSIDER&quot;,&#10;        &quot;player-3-uuid&quot;: &quot;PLAYER&quot;&#10;      },&#10;      &quot;cardOpened&quot;: {&#10;        &quot;player-1-uuid&quot;: true,&#10;        &quot;player-2-uuid&quot;: true,&#10;        &quot;player-3-uuid&quot;: true&#10;      },&#10;      &quot;votes&quot;: {&#10;        &quot;player-1-uuid&quot;: &quot;player-2-uuid&quot;,&#10;        &quot;player-3-uuid&quot;: &quot;player-2-uuid&quot;&#10;      },&#10;      &quot;scores&quot;: {&#10;        &quot;player-1-uuid&quot;: 10,&#10;        &quot;player-2-uuid&quot;: 0,&#10;        &quot;player-3-uuid&quot;: 10&#10;      },&#10;      &quot;voteResult&quot;: {&#10;        &quot;insiderUuid&quot;: &quot;player-2-uuid&quot;,&#10;        &quot;mostVotedUuid&quot;: &quot;player-2-uuid&quot;,&#10;        &quot;mostVotedCount&quot;: 2,&#10;        &quot;voteTally&quot;: {&#10;          &quot;player-2-uuid&quot;: 2&#10;        }&#10;      },&#10;      &quot;gameOutcome&quot;: &quot;INSIDER_FOUND&quot;&#10;    }&#10;  ],&#10;  &quot;status&quot;: &quot;OK&quot;&#10;}&#10;```&#10;&#10;### 2. GET /api/game/{roomCode}/active&#10;ดึงเกมที่กำลังเล่นอยู่ในปัจจุบัน (existing endpoint)&#10;&#10;## GameHistoryDto&#10;&#10;DTO สำหรับแสดงประวัติเกมที่มีข้อมูลครบถ้วน:&#10;&#10;```java&#10;@Data&#10;@Builder&#10;public class GameHistoryDto {&#10;    private UUID id;&#10;    private String roomCode;&#10;    private String word;              // คำที่ถูกเปิดเผย&#10;    private boolean wordRevealed;&#10;    private LocalDateTime startedAt;&#10;    private LocalDateTime endsAt;&#10;    private Integer durationSeconds;&#10;    private boolean finished;&#10;    &#10;    private List&lt;PlayerInGame&gt; players;        // ผู้เล่นในเกมนี้&#10;    private Map&lt;String, RoleType&gt; roles;       // บทบาทของแต่ละคน&#10;    private Map&lt;String, Boolean&gt; cardOpened;   // สถานะการเปิดไพ่&#10;    private Map&lt;String, String&gt; votes;         // การโหวต&#10;    private Map&lt;String, Integer&gt; scores;       // คะแนน&#10;    &#10;    private VoteResultDto voteResult;          // สรุปผลการโหวต&#10;    private String gameOutcome;                // ผลลัพธ์ของเกม&#10;}&#10;```&#10;&#10;### Game Outcome Types&#10;- **`INSIDER_FOUND`**: โหวตถูกต้อง - ผู้เล่นทั่วไปชนะ&#10;- **`INSIDER_HIDDEN`**: โหวตผิด - Insider ชนะ&#10;- **`NO_INSIDER`**: ไม่มี Insider ในเกม&#10;&#10;## Vote Result Details&#10;&#10;```java&#10;public static class VoteResultDto {&#10;    private String insiderUuid;           // UUID ของ Insider&#10;    private String mostVotedUuid;         // UUID ของคนที่โดนโหวตมากที่สุด&#10;    private Integer mostVotedCount;       // จำนวนโหวตที่มากที่สุด&#10;    private Map&lt;String, Integer&gt; voteTally; // สรุปคะแนนโหวตทั้งหมด&#10;}&#10;```&#10;&#10;## การใช้งาน Frontend&#10;&#10;### React/Next.js Example&#10;&#10;```typescript&#10;import axios from 'axios';&#10;&#10;const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080';&#10;&#10;// Fetch game history for a room&#10;async function getGameHistory(roomCode: string) {&#10;  try {&#10;    const response = await axios.get(`${API_URL}/api/game/${roomCode}/history`);&#10;    &#10;    if (response.data.success) {&#10;      const games = response.data.data;&#10;      console.log(`Found ${games.length} games in history`);&#10;      &#10;      games.forEach(game =&gt; {&#10;        console.log(`Game ${game.id}:`);&#10;        console.log(`  Word: ${game.word}`);&#10;        console.log(`  Finished: ${game.finished}`);&#10;        console.log(`  Outcome: ${game.gameOutcome}`);&#10;        &#10;        if (game.voteResult) {&#10;          console.log(`  Insider: ${game.voteResult.insiderUuid}`);&#10;          console.log(`  Most Voted: ${game.voteResult.mostVotedUuid}`);&#10;        }&#10;      });&#10;      &#10;      return games;&#10;    }&#10;  } catch (error) {&#10;    console.error('Error fetching game history:', error);&#10;  }&#10;}&#10;&#10;// Example: Display in component&#10;function GameHistoryComponent({ roomCode }: { roomCode: string }) {&#10;  const [history, setHistory] = useState([]);&#10;  &#10;  useEffect(() =&gt; {&#10;    getGameHistory(roomCode).then(data =&gt; setHistory(data || []));&#10;  }, [roomCode]);&#10;  &#10;  return (&#10;    &lt;div&gt;&#10;      &lt;h2&gt;Game History&lt;/h2&gt;&#10;      {history.map(game =&gt; (&#10;        &lt;div key={game.id}&gt;&#10;          &lt;h3&gt;Game: {game.word}&lt;/h3&gt;&#10;          &lt;p&gt;Outcome: {game.gameOutcome}&lt;/p&gt;&#10;          &lt;p&gt;Players: {game.players.length}&lt;/p&gt;&#10;          {/* Display more details */}&#10;        &lt;/div&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;```&#10;&#10;## ข้อจำกัดปัจจุบัน&#10;&#10;### In-Memory Storage&#10;⚠️ **สำคัญ**: ข้อมูลถูกเก็บใน memory เท่านั้น &#10;- ถ้า restart server → **ประวัติจะหายทั้งหมด**&#10;- ไม่มี persistence (database)&#10;&#10;### แนวทางแก้ไข (Future Enhancement)&#10;&#10;#### Option 1: เพิ่ม Database (แนะนำ)&#10;```java&#10;// Add JPA Entity&#10;@Entity&#10;@Table(name = &quot;games&quot;)&#10;public class GameEntity {&#10;    @Id&#10;    private UUID id;&#10;    &#10;    @Column(name = &quot;room_code&quot;)&#10;    private String roomCode;&#10;    &#10;    @Column(name = &quot;word&quot;)&#10;    private String word;&#10;    &#10;    // ... other fields&#10;    &#10;    @Column(name = &quot;roles&quot;, columnDefinition = &quot;json&quot;)&#10;    @Convert(converter = JsonConverter.class)&#10;    private Map&lt;String, RoleType&gt; roles;&#10;}&#10;&#10;// Add Repository&#10;@Repository&#10;public interface GameRepository extends JpaRepository&lt;GameEntity, UUID&gt; {&#10;    List&lt;GameEntity&gt; findByRoomCodeOrderByStartedAtDesc(String roomCode);&#10;}&#10;```&#10;&#10;#### Option 2: Export to File&#10;```java&#10;// Add export endpoint&#10;@GetMapping(&quot;/{roomCode}/history/export&quot;)&#10;public ResponseEntity&lt;Resource&gt; exportGameHistory(@PathVariable String roomCode) {&#10;    // Export to JSON/CSV file&#10;}&#10;```&#10;&#10;## Files Changed/Created&#10;&#10;### New Files&#10;1. **`src/main/java/com/insidergame/insider_api/dto/GameHistoryDto.java`**&#10;   - DTO for game history display&#10;   - Includes vote results and game outcome&#10;&#10;### Modified Files&#10;2. **`src/main/java/com/insidergame/insider_api/api/game/GameController.java`**&#10;   - Added `GET /api/game/{roomCode}/history` endpoint&#10;   - Added `convertToHistoryDto()` method for converting Game to DTO&#10;&#10;### Existing Files (Already Working)&#10;3. **`src/main/java/com/insidergame/insider_api/manager/GameManager.java`**&#10;   - `gamesByRoom` - stores all games&#10;   - `getGamesForRoom()` - retrieves game history&#10;   - `finishAndArchiveGame()` - archives finished games&#10;&#10;4. **`src/main/java/com/insidergame/insider_api/api/game/GameServiceImpl.java`**&#10;   - `getGamesForRoom()` service method (already implemented)&#10;&#10;## Testing&#10;&#10;### Test Endpoint&#10;```bash&#10;# 1. Create a room and play some games&#10;# ...&#10;&#10;# 2. Get game history&#10;curl -X GET http://localhost:8080/api/game/ABCD1234/history&#10;&#10;# Expected: List of all games played in room ABCD1234&#10;```&#10;&#10;### Test Scenarios&#10;1. ✅ Play multiple games in a room&#10;2. ✅ Finish games with voting&#10;3. ✅ Fetch history - should show all games&#10;4. ✅ Restart server - history will be lost (in-memory)&#10;&#10;## Summary&#10;&#10;✅ **มีระบบเก็บประวัติแล้ว** - ทำงานผ่าน `GameManager.gamesByRoom`&#10;✅ **มี API ดึงประวัติแล้ว** - `GET /api/game/{roomCode}/history`&#10;✅ **มี DTO สวยงาม** - `GameHistoryDto` พร้อม vote results และ game outcome&#10;⚠️ **ข้อจำกัด** - In-memory เท่านั้น (หายเมื่อ restart)&#10; **แนะนำ** - เพิ่ม database persistence ในอนาคต&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HOST_TRANSFER_FEATURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HOST_TRANSFER_FEATURE.md" />
              <option name="updatedContent" value="# Host Transfer Feature - Implementation Summary&#10;&#10;## ✅ Feature Overview&#10;ระบบถ่ายโอนหัวห้องอัตโนมัติเมื่อหัวห้องคนเดิม leave ออกไป โดยคนที่จะได้รับหัวห้องเป็นคนที่เข้ามาล่าสุดต่อจากหัวห้องคนเก่า&#10;&#10;##  How It Works&#10;&#10;### Logic Flow:&#10;```&#10;1. Host leaves room&#10;   ↓&#10;2. Find host's joinedAt timestamp&#10;   ↓&#10;3. Find player who joined RIGHT AFTER host&#10;   (smallest joinedAt &gt; host's joinedAt)&#10;   ↓&#10;4. Transfer host privileges to that player&#10;   ↓&#10;5. Broadcast &quot;HOST_TRANSFERRED&quot; message&#10;```&#10;&#10;### Example Scenario:&#10;```&#10;Room: ABC123&#10;Players joined in order:&#10;  1. Alice (Host)   - joinedAt: 10:00:00&#10;  2. Bob            - joinedAt: 10:00:05&#10;  3. Charlie        - joinedAt: 10:00:10&#10;  4. Dave           - joinedAt: 10:00:15&#10;&#10;When Alice leaves:&#10;  → Bob becomes new host (เข้ามาล่าสุดต่อจาก Alice)&#10;  &#10;When Bob leaves:&#10;  → Charlie becomes new host&#10;  &#10;When Charlie leaves:&#10;  → Dave becomes new host&#10;  &#10;When Dave leaves:&#10;  → Room is deleted (empty)&#10;```&#10;&#10;### Edge Cases Handled:&#10;&#10;#### Case 1: No player joined after host&#10;```&#10;Players:&#10;  1. Bob   - joinedAt: 10:00:05&#10;  2. Alice (Host) - joinedAt: 10:00:10&#10;&#10;When Alice leaves:&#10;  → Bob becomes host (wraparound to earliest player)&#10;```&#10;&#10;#### Case 2: Missing joinedAt timestamps&#10;```&#10;If timestamps are null:&#10;  → Fallback to first player in set&#10;```&#10;&#10;#### Case 3: Only 2 players&#10;```&#10;Players:&#10;  1. Alice (Host)&#10;  2. Bob&#10;&#10;When Alice leaves:&#10;  → Bob becomes host&#10;```&#10;&#10;#### Case 4: Host leaves, room empty&#10;```&#10;Players:&#10;  1. Alice (Host)&#10;&#10;When Alice leaves:&#10;  → Room is deleted&#10;```&#10;&#10;---&#10;&#10;##  Files Modified&#10;&#10;### 1. RoomManager.java&#10;**Location:** `/src/main/java/com/insidergame/insider_api/manager/RoomManager.java`&#10;&#10;**Changes:**&#10;- ✅ Updated `removePlayerFromRoom()` - Improved host transfer logic&#10;- ✅ Added `findNextHost()` - Find next host based on joinedAt timestamp&#10;&#10;**Key Methods:**&#10;```java&#10;// Main removal logic with host transfer&#10;public boolean removePlayerFromRoom(String roomCode, String playerUuid)&#10;&#10;// Find player who joined right after the host&#10;private Player findNextHost(Room room, LocalDateTime hostJoinedAt)&#10;```&#10;&#10;**Algorithm:**&#10;1. Store host's `joinedAt` before removing player&#10;2. After removal, find player with smallest `joinedAt` &gt; host's `joinedAt`&#10;3. If no such player, wraparound to earliest joined player&#10;4. Set new host flags and update room&#10;&#10;### 2. RoomWebSocketController.java&#10;**Location:** `/src/main/java/com/insidergame/insider_api/websocket/RoomWebSocketController.java`&#10;&#10;**Changes:**&#10;- ✅ Updated `leaveRoom()` - Detect and broadcast host transfer&#10;&#10;**Key Changes:**&#10;```java&#10;// Detect if leaving player was host&#10;boolean wasHost = request.getPlayerUuid().equals(room.getHostUuid());&#10;&#10;// After removal, check if host changed&#10;boolean hostChanged = wasHost &amp;&amp; !room.getHostUuid().equals(oldHostUuid);&#10;&#10;// Broadcast appropriate message&#10;if (hostChanged) {&#10;    broadcastRoomUpdate(roomCode, &quot;HOST_TRANSFERRED&quot;);&#10;} else {&#10;    broadcastRoomUpdate(roomCode, &quot;PLAYER_LEFT&quot;);&#10;}&#10;```&#10;&#10;---&#10;&#10;##  WebSocket Messages&#10;&#10;### New Message Type: HOST_TRANSFERRED&#10;&#10;**Topic:** `/topic/room/{roomCode}`&#10;&#10;**When:** Host leaves and new host is assigned&#10;&#10;**Payload:**&#10;```json&#10;{&#10;  &quot;type&quot;: &quot;HOST_TRANSFERRED&quot;,&#10;  &quot;roomCode&quot;: &quot;ABC123&quot;,&#10;  &quot;roomName&quot;: &quot;Game Room&quot;,&#10;  &quot;maxPlayers&quot;: 8,&#10;  &quot;currentPlayers&quot;: 3,&#10;  &quot;status&quot;: &quot;WAITING&quot;,&#10;  &quot;hostUuid&quot;: &quot;new-host-uuid&quot;,&#10;  &quot;players&quot;: [&#10;    {&#10;      &quot;uuid&quot;: &quot;new-host-uuid&quot;,&#10;      &quot;playerName&quot;: &quot;Bob&quot;,&#10;      &quot;isHost&quot;: true,&#10;      &quot;isReady&quot;: false,&#10;      &quot;isActive&quot;: true&#10;    },&#10;    // ... other players&#10;  ],&#10;  &quot;message&quot;: &quot;HOST_TRANSFERRED&quot;&#10;}&#10;```&#10;&#10;---&#10;&#10;##  Frontend Integration&#10;&#10;### Subscribe to Room Updates&#10;```javascript&#10;stompClient.subscribe(`/topic/room/${roomCode}`, (message) =&gt; {&#10;  const data = JSON.parse(message.body);&#10;  &#10;  switch(data.message) {&#10;    case 'HOST_TRANSFERRED':&#10;      // Old host left, new host assigned&#10;      const newHostUuid = data.hostUuid;&#10;      const newHost = data.players.find(p =&gt; p.isHost);&#10;      &#10;      // Update UI to show new host&#10;      updateHostIndicator(newHost);&#10;      &#10;      // If current user is new host, show host controls&#10;      if (newHostUuid === currentUserUuid) {&#10;        showHostControls();&#10;        showNotification('คุณได้รับตำแหน่งหัวห้อง');&#10;      } else {&#10;        showNotification(`${newHost.playerName} เป็นหัวห้องคนใหม่`);&#10;      }&#10;      break;&#10;      &#10;    case 'PLAYER_LEFT':&#10;      // Regular player left (not host)&#10;      updatePlayerList(data.players);&#10;      break;&#10;      &#10;    case 'ROOM_UPDATE':&#10;      // Room deleted or general update&#10;      updateRoomState(data);&#10;      break;&#10;  }&#10;});&#10;```&#10;&#10;### Example UI Update&#10;```javascript&#10;function updateHostIndicator(newHost) {&#10;  // Remove host badge from all players&#10;  document.querySelectorAll('.host-badge').forEach(badge =&gt; {&#10;    badge.remove();&#10;  });&#10;  &#10;  // Add host badge to new host&#10;  const newHostElement = document.querySelector(`[data-uuid=&quot;${newHost.uuid}&quot;]`);&#10;  if (newHostElement) {&#10;    const badge = document.createElement('span');&#10;    badge.className = 'host-badge';&#10;    badge.textContent = ' Host';&#10;    newHostElement.appendChild(badge);&#10;  }&#10;}&#10;&#10;function showHostControls() {&#10;  // Show host-only buttons&#10;  document.getElementById('start-game-btn').style.display = 'block';&#10;  document.getElementById('delete-room-btn').style.display = 'block';&#10;  document.getElementById('room-settings-btn').style.display = 'block';&#10;}&#10;```&#10;&#10;---&#10;&#10;## ✅ Testing Guide&#10;&#10;### Test Case 1: Basic Host Transfer&#10;**Steps:**&#10;1. Create room (Player A becomes host)&#10;2. Player B joins&#10;3. Player C joins&#10;4. Player A (host) leaves&#10;&#10;**Expected Result:**&#10;- ✅ Player B becomes new host&#10;- ✅ Broadcast message: &quot;HOST_TRANSFERRED&quot;&#10;- ✅ Player B sees host controls&#10;- ✅ UI shows Player B with host badge&#10;&#10;### Test Case 2: Sequential Leaves&#10;**Steps:**&#10;1. Room with 4 players: A (host), B, C, D&#10;2. A leaves → B becomes host&#10;3. B leaves → C becomes host&#10;4. C leaves → D becomes host&#10;5. D leaves → Room deleted&#10;&#10;**Expected Result:**&#10;- ✅ Each transfer follows join order&#10;- ✅ Correct &quot;HOST_TRANSFERRED&quot; broadcasts&#10;- ✅ Room deleted when last player leaves&#10;&#10;### Test Case 3: Wraparound&#10;**Steps:**&#10;1. Player B joins room (first, becomes host)&#10;2. Player A joins room&#10;3. Player B (host) leaves&#10;&#10;**Expected Result:**&#10;- ✅ Player A becomes host (wraparound to earliest)&#10;- ✅ Broadcast &quot;HOST_TRANSFERRED&quot;&#10;&#10;### Test Case 4: Non-Host Leaves&#10;**Steps:**&#10;1. Room with A (host), B, C&#10;2. Player B leaves&#10;&#10;**Expected Result:**&#10;- ✅ Host remains Player A&#10;- ✅ Broadcast message: &quot;PLAYER_LEFT&quot; (not HOST_TRANSFERRED)&#10;- ✅ No host transfer&#10;&#10;### Test Case 5: Multiple Rapid Leaves&#10;**Steps:**&#10;1. Room with 5 players&#10;2. Host leaves immediately&#10;3. New host leaves immediately&#10;4. Continue...&#10;&#10;**Expected Result:**&#10;- ✅ Host transfers correctly in sequence&#10;- ✅ No race conditions&#10;- ✅ Room state always consistent&#10;&#10;### Test Case 6: During Active Game&#10;**Steps:**&#10;1. Start game with 4 players&#10;2. Host leaves during game&#10;&#10;**Expected Result:**&#10;- ✅ Host transfers correctly&#10;- ✅ Game continues (if game logic allows)&#10;- ✅ New host can manage room&#10;&#10;---&#10;&#10;##  Verification Checklist&#10;&#10;### Backend:&#10;- [ ] Host transfer uses `joinedAt` timestamp&#10;- [ ] Next player in join order becomes host&#10;- [ ] Wraparound works when no player joined after host&#10;- [ ] Room deleted when empty&#10;- [ ] Correct WebSocket message sent&#10;- [ ] Logs show host transfer details&#10;&#10;### Frontend:&#10;- [ ] HOST_TRANSFERRED message received&#10;- [ ] UI updates to show new host&#10;- [ ] New host sees host controls&#10;- [ ] Old host controls removed&#10;- [ ] Notification shown to users&#10;- [ ] Player list updated correctly&#10;&#10;### Edge Cases:&#10;- [ ] Works with 2 players&#10;- [ ] Works with max players&#10;- [ ] Handles null joinedAt gracefully&#10;- [ ] No errors when room deleted&#10;- [ ] Works during different room states (WAITING, PLAYING)&#10;&#10;---&#10;&#10;##  Troubleshooting&#10;&#10;### Host not transferred&#10;**Check:**&#10;- Verify `joinedAt` timestamps are set when players join&#10;- Check logs for &quot;Host transferred&quot; message&#10;- Ensure `removePlayerFromRoom()` is called&#10;&#10;### Wrong player becomes host&#10;**Check:**&#10;- Verify `joinedAt` order matches join order&#10;- Check if timestamps are unique (millisecond precision)&#10;- Review `findNextHost()` logic&#10;&#10;### HOST_TRANSFERRED not broadcasted&#10;**Check:**&#10;- Ensure leaving player was actually the host&#10;- Verify WebSocket connection&#10;- Check broadcast logic in `leaveRoom()`&#10;&#10;### Room not deleted when empty&#10;**Check:**&#10;- Verify `room.isEmpty()` returns true&#10;- Check if players are properly removed&#10;- Review `removePlayerFromRoom()` logic&#10;&#10;---&#10;&#10;##  Algorithm Complexity&#10;&#10;### Time Complexity:&#10;- **removePlayerFromRoom:** O(n) where n = number of players&#10;  - Remove player: O(n)&#10;  - Find next host: O(n)&#10;  &#10;- **findNextHost:** O(n)&#10;  - Filter players: O(n)&#10;  - Find minimum: O(n)&#10;&#10;### Space Complexity:&#10;- O(1) - Only temporary variables&#10;&#10;### Performance:&#10;- Efficient for typical room sizes (&lt; 10 players)&#10;- No memory leaks&#10;- Thread-safe (ConcurrentHashMap used in RoomManager)&#10;&#10;---&#10;&#10;##  Future Enhancements&#10;&#10;### Optional Features:&#10;- [ ] Manual host transfer API (host can transfer to anyone)&#10;- [ ] Host transfer vote system&#10;- [ ] Co-host system (multiple hosts)&#10;- [ ] Host transfer history/log&#10;- [ ] Prevent host transfer during critical game moments&#10;&#10;### Configuration:&#10;- [ ] Allow host to set transfer order policy&#10;- [ ] Configurable fallback strategies&#10;- [ ] Auto-promote most active player option&#10;&#10;---&#10;&#10;##  Related Files&#10;&#10;### Core Files:&#10;- `RoomManager.java` - Host transfer logic&#10;- `RoomWebSocketController.java` - WebSocket handling&#10;- `Player.java` - Player model with joinedAt&#10;- `Room.java` - Room model&#10;&#10;### Related Features:&#10;- Player join/leave system&#10;- WebSocket real-time updates&#10;- Room lifecycle management&#10;&#10;---&#10;&#10;## ✨ Status: ✅ COMPLETE&#10;&#10;Feature fully implemented and ready for testing!&#10;&#10;**Key Points:**&#10;- ✅ Host transfers to next player in join order&#10;- ✅ Based on `joinedAt` timestamp&#10;- ✅ Handles all edge cases&#10;- ✅ Broadcasts HOST_TRANSFERRED message&#10;- ✅ Frontend integration ready&#10;- ✅ No compilation errors&#10;&#10;**Implementation Date:** December 1, 2025&#10;**Next Step:** Test with real players! &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HOST_TRANSFER_QUICK.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HOST_TRANSFER_QUICK.md" />
              <option name="updatedContent" value="#  Host Transfer - Quick Reference&#10;&#10;## สรุปสั้นๆ&#10;&#10;### ฟีเจอร์:&#10;เมื่อหัวห้อง leave ออกไป → คนที่เข้ามาล่าสุดต่อจากหัวห้องจะได้รับตำแหน่งหัวห้อง&#10;&#10;### ตัวอย่าง:&#10;```&#10;ลำดับการเข้าห้อง:&#10;1. Alice (Host) &#10;2. Bob&#10;3. Charlie&#10;4. Dave&#10;&#10;Alice leave → Bob เป็นหัวห้องใหม่ &#10;Bob leave → Charlie เป็นหัวห้องใหม่ &#10;Charlie leave → Dave เป็นหัวห้องใหม่ &#10;Dave leave → ห้องถูกลบ ️&#10;```&#10;&#10;---&#10;&#10;##  ไฟล์ที่แก้ไข&#10;&#10;### RoomManager.java&#10;- ✅ `removePlayerFromRoom()` - เพิ่ม logic ถ่ายโอนหัวห้อง&#10;- ✅ `findNextHost()` - หาคนที่เข้ามาต่อจากหัวห้อง&#10;&#10;### RoomWebSocketController.java&#10;- ✅ `leaveRoom()` - ส่ง broadcast &quot;HOST_TRANSFERRED&quot;&#10;&#10;---&#10;&#10;##  WebSocket Message&#10;&#10;### ข้อความใหม่: HOST_TRANSFERRED&#10;```json&#10;{&#10;  &quot;message&quot;: &quot;HOST_TRANSFERRED&quot;,&#10;  &quot;roomCode&quot;: &quot;ABC123&quot;,&#10;  &quot;hostUuid&quot;: &quot;new-host-uuid&quot;,&#10;  &quot;players&quot;: [...]&#10;}&#10;```&#10;&#10;---&#10;&#10;##  ทดสอบง่ายๆ&#10;&#10;### Test 1: ถ่ายโอนพื้นฐาน&#10;```&#10;1. สร้างห้อง (A เป็น host)&#10;2. B เข้าห้อง&#10;3. A leave&#10;→ คาดหวัง: B เป็น host ✅&#10;```&#10;&#10;### Test 2: ถ่ายโอนต่อเนื่อง&#10;```&#10;1. ห้องมี A, B, C, D&#10;2. A leave → B เป็น host&#10;3. B leave → C เป็น host&#10;4. C leave → D เป็น host&#10;5. D leave → ห้องถูกลบ&#10;→ คาดหวัง: ถ่ายโอนถูกต้องทุกครั้ง ✅&#10;```&#10;&#10;### Test 3: คนธรรมดา leave&#10;```&#10;1. ห้องมี A (host), B, C&#10;2. B leave&#10;→ คาดหวัง: A ยังเป็น host, ไม่มีการถ่ายโอน ✅&#10;```&#10;&#10;---&#10;&#10;##  Frontend Code&#10;&#10;```javascript&#10;stompClient.subscribe(`/topic/room/${roomCode}`, (msg) =&gt; {&#10;  const data = JSON.parse(msg.body);&#10;  &#10;  if (data.message === 'HOST_TRANSFERRED') {&#10;    const newHost = data.players.find(p =&gt; p.isHost);&#10;    &#10;    // อัพเดต UI&#10;    updateHostBadge(newHost);&#10;    &#10;    // ถ้าเราเป็น host คนใหม่&#10;    if (data.hostUuid === myUuid) {&#10;      showHostControls();&#10;      alert('คุณเป็นหัวห้องคนใหม่! ');&#10;    }&#10;  }&#10;});&#10;```&#10;&#10;---&#10;&#10;## ✅ สถานะ: พร้อมใช้งาน!&#10;&#10;- ✅ ใช้ `joinedAt` timestamp&#10;- ✅ หาคนที่เข้ามาต่อจาก host&#10;- ✅ จัดการ edge cases ทั้งหมด&#10;- ✅ ส่ง broadcast message&#10;- ✅ ไม่มี error&#10;&#10;---&#10;&#10;##  เอกสารเพิ่มเติม&#10;&#10;ดูรายละเอียดเต็มที่: **HOST_TRANSFER_FEATURE.md**&#10;&#10;---&#10;&#10;**Status:** ✅ Complete&#10;**Ready to test!** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/VOTE_FIX_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/VOTE_FIX_SUMMARY.md" />
              <option name="updatedContent" value="# Fix: activeGame.votes Not Showing After Player Vote&#10;&#10;## Problem&#10;After calling `playerVote()`, the `activeGame` field `votes` was not visible in the frontend.&#10;&#10;## Root Causes&#10;&#10;### 1. **Backend**: Votes field was missing from active_game response&#10;The `currentGame()` handler in `RoomWebSocketController` was not including the `votes` field when building the gameMap response.&#10;&#10;### 2. **Frontend**: No request for updated activeGame after voting&#10;The `playerVote()` function was sending the vote but not requesting the updated active game data to see the votes.&#10;&#10;### 3. **Frontend**: Missing VOTE_CAST trigger&#10;The room update subscription wasn't listening for `VOTE_CAST` events to trigger an active game refresh.&#10;&#10;## Solution&#10;&#10;### Backend Fix ✅&#10;**File**: `RoomWebSocketController.java`&#10;&#10;Added `votes` field to the active_game response payload:&#10;&#10;```java&#10;gameMap.put(&quot;votes&quot;, g.getVotes());&#10;```&#10;&#10;Now when clients request `/app/room/{roomCode}/active_game`, they receive:&#10;```json&#10;{&#10;  &quot;game&quot;: {&#10;    &quot;id&quot;: &quot;...&quot;,&#10;    &quot;votes&quot;: {&#10;      &quot;player-uuid-1&quot;: &quot;target-uuid-a&quot;,&#10;      &quot;player-uuid-2&quot;: &quot;target-uuid-b&quot;&#10;    },&#10;    &quot;cardOpened&quot;: {...},&#10;    ...&#10;  }&#10;}&#10;```&#10;&#10;### Frontend Fix ✅&#10;**File**: `useRoomWebSocket.ts` (or `useRoomWebSocket_updated.ts`)&#10;&#10;#### 1. Added VOTE_CAST listener&#10;```typescript&#10;if (&#10;  update.type === &quot;CARD_OPENED&quot; ||&#10;  update.type === &quot;GAME_STARTED&quot; ||&#10;  update.type === &quot;VOTE_CAST&quot; ||      // ← NEW&#10;  update.type === &quot;VOTE_STARTED&quot; ||   // ← NEW&#10;  (update.activeGame !== undefined &amp;&amp; update.activeGame !== null)&#10;) {&#10;  // Request updated active game&#10;  clientRef.current.publish({&#10;    destination: `/app/room/${roomCode}/active_game`,&#10;    body: JSON.stringify({ playerUuid }),&#10;  });&#10;}&#10;```&#10;&#10;#### 2. Auto-request after voting&#10;```typescript&#10;const playerVote = useCallback(&#10;  (targetPlayerUuid: string) =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      // Send vote&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/vote`,&#10;        body: JSON.stringify({ playerUuid, targetPlayerUuid }),&#10;      });&#10;      &#10;      // Immediately request active game to see updated votes&#10;      setTimeout(() =&gt; {&#10;        if (clientRef.current?.connected) {&#10;          clientRef.current.publish({&#10;            destination: `/app/room/${roomCode}/active_game`,&#10;            body: JSON.stringify({ playerUuid }),&#10;          });&#10;        }&#10;      }, 100);&#10;    }&#10;  },&#10;  [roomCode, playerUuid, isConnected]&#10;);&#10;```&#10;&#10;## How It Works Now&#10;&#10;### Flow:&#10;1. **Player clicks vote** → `playerVote(targetUuid)` called&#10;2. **Vote sent** → Server receives at `/app/room/{roomCode}/vote`&#10;3. **Server updates** → `GameManager.recordVote()` stores vote in `Game.votes` map&#10;4. **Server broadcasts** → `VOTE_CAST` message to `/topic/room/{roomCode}`&#10;5. **Frontend receives** → `VOTE_CAST` in room subscription&#10;6. **Frontend requests** → `/app/room/{roomCode}/active_game`&#10;7. **Server responds** → `/user/queue/active_game` with updated votes field&#10;8. **Frontend updates** → `setActiveGame(game)` with votes visible&#10;&#10;### Result:&#10;```typescript&#10;activeGame.votes = {&#10;  &quot;uuid-player-1&quot;: &quot;uuid-target-a&quot;,&#10;  &quot;uuid-player-2&quot;: &quot;uuid-target-b&quot;,&#10;  &quot;uuid-player-3&quot;: &quot;uuid-target-a&quot;&#10;}&#10;```&#10;&#10;## Testing&#10;1. Start a game with multiple players&#10;2. Trigger voting phase (master_end)&#10;3. Each player calls `playerVote(targetUuid)`&#10;4. Check browser console for:&#10;   - `️ Player is voting for: [uuid]`&#10;   - `Room update received: { type: &quot;VOTE_CAST&quot; }`&#10;   - ` Requesting active game after vote...`&#10;   - ` active_game (user queue) received: { votes: {...} }`&#10;5. Verify `activeGame.votes` object in React state contains all votes&#10;&#10;## Additional Notes&#10;- Votes can be changed (new vote overwrites previous vote from same voter)&#10;- Only participants (players with roles) can vote&#10;- The `votes` map is initialized as empty `{}` when game is created&#10;- Votes persist across reconnects (stored in server memory via GameManager)&#10;&#10;## Files Modified&#10;1. `/src/main/java/com/insidergame/insider_api/websocket/RoomWebSocketController.java`&#10;2. `/hooks/useRoomWebSocket.ts` (create updated version as `useRoomWebSocket_updated.ts`)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/WORD_NO_DUPLICATE_FEATURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/WORD_NO_DUPLICATE_FEATURE.md" />
              <option name="updatedContent" value="# Random Word Without Duplication Feature&#10;&#10;## สรุป&#10;ระบบจะไม่ random คำซ้ำกับคำที่เคยใช้ในห้องนั้นๆ แล้ว จนกว่าคำทั้งหมดจะถูกใช้หมด แล้วค่อย reset และเริ่มใช้ใหม่&#10;&#10;## การทำงาน&#10;&#10;### Before (เดิม)&#10;```java&#10;// Pick random word - อาจซ้ำกับเกมก่อนหน้า&#10;CategoryEntity pick = categories.get(new Random().nextInt(categories.size()));&#10;String word = pick.getCategoryName();&#10;```&#10;&#10;### After (แก้ไขแล้ว)&#10;```java&#10;// 1. ดึงประวัติเกมในห้องนี้&#10;List&lt;Game&gt; previousGames = gameManager.getGamesForRoom(roomCode);&#10;&#10;// 2. เก็บ Set ของคำที่เคยใช้แล้ว&#10;Set&lt;String&gt; usedWords = previousGames.stream()&#10;    .map(Game::getWord)&#10;    .filter(Objects::nonNull)&#10;    .collect(Collectors.toSet());&#10;&#10;// 3. กรองเอาเฉพาะคำที่ยังไม่เคยใช้&#10;List&lt;CategoryEntity&gt; availableCategories = categories.stream()&#10;    .filter(cat -&gt; !usedWords.contains(cat.getCategoryName()))&#10;    .collect(Collectors.toList());&#10;&#10;// 4. ถ้าคำหมดแล้ว (ใช้ครบทุกคำ) → reset ให้ใช้ได้ทั้งหมด&#10;if (availableCategories.isEmpty()) {&#10;    availableCategories = new ArrayList&lt;&gt;(categories);&#10;}&#10;&#10;// 5. Random จากคำที่พร้อมใช้งาน&#10;CategoryEntity pick = availableCategories.get(new Random().nextInt(availableCategories.size()));&#10;String word = pick.getCategoryName();&#10;```&#10;&#10;## Logic Flow&#10;&#10;```&#10;┌─────────────────────────────────────────┐&#10;│  Start Game in Room ABCD                │&#10;└───────────────┬─────────────────────────┘&#10;                │&#10;                ▼&#10;┌─────────────────────────────────────────┐&#10;│  Get all categories (total: 100 words)  │&#10;└───────────────┬─────────────────────────┘&#10;                │&#10;                ▼&#10;┌─────────────────────────────────────────┐&#10;│  Get game history for room ABCD         │&#10;│  - Game 1: word = &quot;แมว&quot;                 │&#10;│  - Game 2: word = &quot;หมา&quot;                 │&#10;│  - Game 3: word = &quot;ปลา&quot;                 │&#10;└───────────────┬─────────────────────────┘&#10;                │&#10;                ▼&#10;┌─────────────────────────────────────────┐&#10;│  Create usedWords Set:                  │&#10;│  { &quot;แมว&quot;, &quot;หมา&quot;, &quot;ปลา&quot; }              │&#10;└───────────────┬─────────────────────────┘&#10;                │&#10;                ▼&#10;┌─────────────────────────────────────────┐&#10;│  Filter available categories            │&#10;│  100 - 3 = 97 words available           │&#10;└───────────────┬─────────────────────────┘&#10;                │&#10;                ▼&#10;┌─────────────────────────────────────────┐&#10;│  Random from 97 available words         │&#10;│  Selected: &quot;นก&quot; (not used before)       │&#10;└─────────────────────────────────────────┘&#10;```&#10;&#10;## Edge Cases&#10;&#10;### Case 1: ห้องใหม่ (ไม่มีประวัติ)&#10;```&#10;previousGames = []&#10;usedWords = {}&#10;availableCategories = all categories (100 words)&#10;→ Random ได้ทั้ง 100 คำ&#10;```&#10;&#10;### Case 2: เล่นไปแล้ว 50 เกม&#10;```&#10;previousGames = [Game1, Game2, ..., Game50]&#10;usedWords = {50 unique words}&#10;availableCategories = 100 - 50 = 50 words&#10;→ Random ได้เฉพาะ 50 คำที่ยังไม่ใช้&#10;```&#10;&#10;### Case 3: ใช้คำหมดแล้ว (100 เกม)&#10;```&#10;previousGames = [Game1, Game2, ..., Game100]&#10;usedWords = {100 words} (all used)&#10;availableCategories = [] (empty!)&#10;&#10;→ Reset: availableCategories = all categories (100 words)&#10;→ Random ได้ทั้ง 100 คำอีกครั้ง (เริ่มรอบใหม่)&#10;```&#10;&#10;### Case 4: คำซ้ำในประวัติ (แต่ละเกมอาจมีคำเดิมหลายครั้ง)&#10;```&#10;previousGames:&#10;  - Game 1: word = &quot;แมว&quot;&#10;  - Game 2: word = &quot;หมา&quot;&#10;  - Game 3: word = &quot;แมว&quot;  ← ซ้ำกับ Game 1&#10;  &#10;usedWords = {&quot;แมว&quot;, &quot;หมา&quot;}  ← Set ทำให้ไม่ซ้ำ&#10;→ Count เป็น 2 คำที่ใช้แล้ว (ไม่ใช่ 3)&#10;```&#10;&#10;## Benefits&#10;&#10;### ✅ ไม่ซ้ำคำในห้องเดียวกัน&#10;- ผู้เล่นจะได้เล่นคำใหม่ๆ ในแต่ละเกม&#10;- ไม่น่าเบื่อ ไม่ซ้ำซาก&#10;&#10;### ✅ Reset อัตโนมัติ&#10;- เมื่อใช้คำหมดแล้ว จะ reset ให้เล่นได้ใหม่&#10;- ไม่ต้อง manual reset&#10;&#10;### ✅ แยกตามห้อง&#10;- ห้อง A ใช้คำ &quot;แมว&quot; → ห้อง B ยังใช้ &quot;แมว&quot; ได้&#10;- ประวัติแยกกันตามห้อง&#10;&#10;### ✅ Performance ดี&#10;- ใช้ `Set` สำหรับ lookup → O(1)&#10;- Filter ด้วย Stream → efficient&#10;&#10;## Example Scenarios&#10;&#10;### Scenario 1: เริ่มเล่นครั้งแรก&#10;```&#10;Room: TEST123&#10;Total categories: 100&#10;Previous games: 0&#10;&#10;→ Random from all 100 words&#10;→ Selected: &quot;แมว&quot;&#10;```&#10;&#10;### Scenario 2: เล่นเกมที่ 2&#10;```&#10;Room: TEST123&#10;Total categories: 100&#10;Previous games: 1&#10;  - Game 1: &quot;แมว&quot;&#10;&#10;→ Exclude: &quot;แมว&quot;&#10;→ Available: 99 words&#10;→ Random from 99 words&#10;→ Selected: &quot;หมา&quot;&#10;```&#10;&#10;### Scenario 3: เล่นเกมที่ 101 (ใช้ครบแล้ว)&#10;```&#10;Room: TEST123&#10;Total categories: 100&#10;Previous games: 100&#10;  - Used all 100 words&#10;&#10;→ Available: 0 words (empty!)&#10;→ Reset to all 100 words&#10;→ Random from 100 words&#10;→ Selected: &quot;แมว&quot; (can reuse now)&#10;```&#10;&#10;## Code Changes&#10;&#10;### Modified File&#10;`src/main/java/com/insidergame/insider_api/api/game/GameServiceImpl.java`&#10;&#10;#### Changes:&#10;1. **Line 47-71**: Added logic to:&#10;   - Get game history for room&#10;   - Build set of used words&#10;   - Filter available categories&#10;   - Reset if all words used&#10;   - Random from available words&#10;&#10;## Testing&#10;&#10;### Test Case 1: New Room&#10;```bash&#10;# Setup: 10 words in database&#10;# Room: NEW001 (no history)&#10;&#10;POST /api/room/NEW001/start&#10;→ Should get random word from all 10 words&#10;→ e.g., &quot;แมว&quot;&#10;```&#10;&#10;### Test Case 2: Play Multiple Games&#10;```bash&#10;# Play 5 games in same room&#10;POST /api/room/NEW001/start  # Game 1 → &quot;แมว&quot;&#10;POST /api/room/NEW001/start  # Game 2 → &quot;หมา&quot; (not &quot;แมว&quot;)&#10;POST /api/room/NEW001/start  # Game 3 → &quot;ปลา&quot; (not &quot;แมว&quot; or &quot;หมา&quot;)&#10;POST /api/room/NEW001/start  # Game 4 → &quot;นก&quot;&#10;POST /api/room/NEW001/start  # Game 5 → &quot;ช้าง&quot;&#10;&#10;# Check history&#10;GET /api/game/NEW001/history&#10;→ Should show 5 games with 5 different words&#10;```&#10;&#10;### Test Case 3: Use All Words (Reset Test)&#10;```bash&#10;# Setup: Only 3 words in database&#10;# Play 4 games&#10;&#10;POST /api/room/NEW001/start  # Game 1 → &quot;แมว&quot;&#10;POST /api/room/NEW001/start  # Game 2 → &quot;หมา&quot;&#10;POST /api/room/NEW001/start  # Game 3 → &quot;ปลา&quot;&#10;POST /api/room/NEW001/start  # Game 4 → &quot;แมว&quot; or &quot;หมา&quot; or &quot;ปลา&quot; (reset!)&#10;&#10;# Should allow reusing words after all are used&#10;```&#10;&#10;### Test Case 4: Different Rooms (Isolation Test)&#10;```bash&#10;# Room A and Room B should have independent histories&#10;&#10;POST /api/room/ROOM_A/start  # Game 1 → &quot;แมว&quot;&#10;POST /api/room/ROOM_B/start  # Game 1 → &quot;แมว&quot; (OK! Different room)&#10;&#10;POST /api/room/ROOM_A/start  # Game 2 → &quot;หมา&quot; (not &quot;แมว&quot;)&#10;POST /api/room/ROOM_B/start  # Game 2 → &quot;หมา&quot; (OK! Different room)&#10;```&#10;&#10;## Database Requirements&#10;&#10;ระบบนี้ทำงานกับข้อมูลที่มีอยู่แล้ว ไม่ต้องเพิ่ม table หรือ field ใหม่:&#10;&#10;- ✅ ใช้ `GameManager.getGamesForRoom()` - มีอยู่แล้ว&#10;- ✅ ใช้ `Game.getWord()` - มีอยู่แล้ว&#10;- ✅ ใช้ `CategoryEntity.getCategoryName()` - มีอยู่แล้ว&#10;&#10;## Performance Considerations&#10;&#10;### Memory Usage&#10;- `Set&lt;String&gt; usedWords` - O(n) where n = number of games played&#10;- ถ้าเล่นไป 1000 เกม → usedWords จะมี ~1000 entries&#10;- แต่ละ entry เป็น String (คำ) → ประมาณ 50 bytes/คำ&#10;- **Total**: ~50KB สำหรับ 1000 เกม → **ยอมรับได้**&#10;&#10;### Time Complexity&#10;- Get game history: O(n)&#10;- Build usedWords Set: O(n)&#10;- Filter categories: O(m) where m = total categories&#10;- Random selection: O(1)&#10;- **Total**: O(n + m) → **Very fast**&#10;&#10;### Optimization (ถ้าจำเป็น)&#10;ถ้าห้องมีเกมเยอะมาก (10,000+ games):&#10;```java&#10;// Cache usedWords in RoomManager&#10;private final Map&lt;String, Set&lt;String&gt;&gt; cachedUsedWords = new ConcurrentHashMap&lt;&gt;();&#10;&#10;// Clear cache when game finishes&#10;public void onGameFinished(String roomCode, String word) {&#10;    cachedUsedWords.computeIfAbsent(roomCode, k -&gt; new HashSet&lt;&gt;()).add(word);&#10;}&#10;```&#10;&#10;## Summary&#10;&#10;✅ **เสร็จแล้ว**: ระบบ random คำไม่ซ้ำในห้องเดียวกัน&#10;✅ **Auto-reset**: เมื่อใช้คำครบจะ reset อัตโนมัติ&#10;✅ **แยกตามห้อง**: แต่ละห้องมีประวัติของตัวเอง&#10;✅ **Performance ดี**: ใช้ Set และ Stream efficiently&#10;✅ **No DB changes**: ใช้ structure ที่มีอยู่แล้ว&#10;&#10;**File Changed:**&#10;- `src/main/java/com/insidergame/insider_api/api/game/GameServiceImpl.java`&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hooks/useRoomWebSocket_fixed.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hooks/useRoomWebSocket_fixed.ts" />
              <option name="updatedContent" value="import { useEffect, useRef, useState, useCallback } from &quot;react&quot;;&#10;import SockJS from &quot;sockjs-client&quot;;&#10;import { Client, IMessage } from &quot;@stomp/stompjs&quot;;&#10;import { RoomUpdateMessage, ActiveGame } from &quot;./interface&quot;;&#10;&#10;const WS_URL = process.env.NEXT_PUBLIC_WS_URL || &quot;http://localhost:8080/ws&quot;;&#10;&#10;export function useRoomWebSocket(roomCode: string, playerUuid: string) {&#10;  const clientRef = useRef&lt;Client | null&gt;(null);&#10;  const [isConnected, setIsConnected] = useState(false);&#10;  const [room, setRoom] = useState&lt;RoomUpdateMessage | null&gt;(null);&#10;  const [activeGame, setActiveGame] = useState&lt;ActiveGame | null&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    const client = new Client({&#10;      webSocketFactory: () =&gt; new SockJS(WS_URL),&#10;      reconnectDelay: 5000,&#10;      heartbeatIncoming: 4000,&#10;      heartbeatOutgoing: 4000,&#10;    });&#10;&#10;    client.onConnect = () =&gt; {&#10;      console.log(&#10;        &quot; WebSocket Connected for room:&quot;,&#10;        roomCode,&#10;        &quot;player:&quot;,&#10;        playerUuid&#10;      );&#10;      setIsConnected(true);&#10;&#10;      // Subscribe to room updates&#10;      client.subscribe(`/topic/room/${roomCode}`, (message: IMessage) =&gt; {&#10;        const update: RoomUpdateMessage = JSON.parse(message.body);&#10;        console.log(&quot;Room update received:&quot;, update);&#10;&#10;        setRoom(update);&#10;&#10;        // QUICK-ON-DEMAND FLOW:&#10;        // Request per-user active game snapshot when:&#10;        //  - the server announced CARD_OPENED (someone opened a card),&#10;        //  - OR the game started (GAME_STARTED) — we need the full game to get roles/cardOpened/endsAt,&#10;        //  - OR a vote was cast (VOTE_CAST) — to see updated votes,&#10;        //  - OR voting started (VOTE_STARTED) — to see initial empty votes {},&#10;        //  - OR the broadcast included an activeGame summary (safety).&#10;        if (&#10;          update.type === &quot;CARD_OPENED&quot; ||&#10;          update.type === &quot;GAME_STARTED&quot; ||&#10;          update.type === &quot;VOTE_CAST&quot; ||&#10;          update.type === &quot;VOTE_STARTED&quot; ||&#10;          update.type === &quot;GAME_FINISHED&quot; ||&#10;          update.type === &quot;GAME_FINISHED_WITH_SCORING&quot; ||&#10;          update.type === &quot;ROOM_RESET_AFTER_GAME&quot; ||&#10;          (update.activeGame !== undefined &amp;&amp; update.activeGame !== null)&#10;        ) {&#10;          if (clientRef.current?.connected &amp;&amp; playerUuid) {&#10;            clientRef.current.publish({&#10;              destination: `/app/room/${roomCode}/active_game`,&#10;              body: JSON.stringify({ playerUuid }),&#10;            });&#10;          }&#10;        }&#10;      });&#10;&#10;      // Subscribe to per-user active_game response (server sends to /user/queue/active_game)&#10;      client.subscribe(&quot;/user/queue/active_game&quot;, (message: IMessage) =&gt; {&#10;        console.log(&quot; @@@ active_game message received:&quot;, message.body);&#10;&#10;        try {&#10;          const payload = JSON.parse(message.body);&#10;          // server might send either { game: {...} } or direct Game object&#10;          // ✅ FIX: Handle both null and undefined properly&#10;          const game = payload &amp;&amp; payload.game !== undefined ? payload.game : payload;&#10;          console.log(&quot; active_game (user queue) received:&quot;, game);&#10;          &#10;          // ✅ FIX: Always set activeGame, even if it's null&#10;          // This ensures the state is cleared when game ends&#10;          setActiveGame(game);&#10;          &#10;        } catch (err) {&#10;          console.error(&quot;❌ Failed parse active_game response:&quot;, err);&#10;        }&#10;      });&#10;&#10;      // join&#10;      client.publish({&#10;        destination: `/app/room/${roomCode}/join`,&#10;        body: JSON.stringify({&#10;          playerUuid,&#10;          active: true,&#10;        }),&#10;      });&#10;&#10;      // ⭐ ALWAYS request active game data after join (especially important on refresh)&#10;      setTimeout(() =&gt; {&#10;        console.log(&quot; Requesting active game data after join/refresh...&quot;);&#10;        if (clientRef.current?.connected &amp;&amp; playerUuid) {&#10;          clientRef.current.publish({&#10;            destination: `/app/room/${roomCode}/active_game`,&#10;            body: JSON.stringify({ playerUuid }),&#10;          });&#10;        }&#10;      }, 1000); // Wait a bit longer for join to complete&#10;&#10;      // sync visibility after join&#10;      setTimeout(() =&gt; {&#10;        const isVisible = document.visibilityState === &quot;visible&quot;;&#10;        if (!isVisible &amp;&amp; clientRef.current?.connected) {&#10;          clientRef.current.publish({&#10;            destination: `/app/room/${roomCode}/status`,&#10;            body: JSON.stringify({&#10;              playerUuid,&#10;              active: false,&#10;            }),&#10;          });&#10;        }&#10;      }, 500);&#10;    };&#10;&#10;    client.onDisconnect = () =&gt; {&#10;      setIsConnected(false);&#10;    };&#10;&#10;    client.onStompError = (frame) =&gt; {&#10;      console.error(&quot;WebSocket error:&quot;, frame);&#10;    };&#10;&#10;    client.activate();&#10;    clientRef.current = client;&#10;&#10;    const handleVisibilityChange = () =&gt; {&#10;      const isVisible = document.visibilityState === &quot;visible&quot;;&#10;      if (clientRef.current?.connected &amp;&amp; playerUuid) {&#10;        clientRef.current.publish({&#10;          destination: `/app/room/${roomCode}/status`,&#10;          body: JSON.stringify({&#10;            playerUuid,&#10;            active: isVisible,&#10;          }),&#10;        });&#10;      }&#10;    };&#10;    document.addEventListener(&quot;visibilitychange&quot;, handleVisibilityChange);&#10;&#10;    return () =&gt; {&#10;      document.removeEventListener(&quot;visibilitychange&quot;, handleVisibilityChange);&#10;      if (clientRef.current?.connected &amp;&amp; playerUuid) {&#10;        try {&#10;          clientRef.current.publish({&#10;            destination: `/app/room/${roomCode}/leave`,&#10;            body: JSON.stringify({ playerUuid }),&#10;          });&#10;        } catch (error) {&#10;          console.error(&quot;Error sending leave message:&quot;, error);&#10;        }&#10;      }&#10;      clientRef.current?.deactivate();&#10;    };&#10;  }, [roomCode, playerUuid]);&#10;&#10;  // Toggle ready&#10;  const toggleReady = useCallback(() =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/ready`,&#10;        body: JSON.stringify({ playerUuid }),&#10;      });&#10;    }&#10;  }, [roomCode, playerUuid, isConnected]);&#10;&#10;  // Start game (host)&#10;  const startGame = useCallback(() =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/start`,&#10;        body: JSON.stringify({ triggerByUuid: playerUuid }),&#10;      });&#10;    }&#10;  }, [roomCode, playerUuid, isConnected]);&#10;&#10;  // Handle card opened (user action)&#10;  const handleCardOpened = useCallback(() =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      console.log(&quot; Opening card for player:&quot;, playerUuid);&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/open_card`,&#10;        body: JSON.stringify({ playerUuid }),&#10;      });&#10;    }&#10;  }, [roomCode, playerUuid, isConnected]);&#10;&#10;  const masterRoleIsSetToVoteTime = useCallback(() =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      console.log(&quot;⏰ Master is setting to vote time...&quot;);&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/master_end`,&#10;        body: JSON.stringify({ playerUuid }),&#10;      });&#10;    }&#10;  }, [roomCode, playerUuid, isConnected]);&#10;&#10;  const playerVote = useCallback(&#10;    (targetPlayerUuid: string) =&gt; {&#10;      if (clientRef.current &amp;&amp; isConnected) {&#10;        console.log(&quot;️ Player is voting...&quot;, targetPlayerUuid);&#10;        clientRef.current.publish({&#10;          destination: `/app/room/${roomCode}/vote`,&#10;          body: JSON.stringify({ playerUuid, targetPlayerUuid }),&#10;        });&#10;      }&#10;    },&#10;    [roomCode, playerUuid, isConnected]&#10;  );&#10;&#10;  const hostSummary = useCallback(() =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      console.log(&quot; Host is requesting game summary...&quot;);&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/host_summary`,&#10;        body: JSON.stringify({ playerUuid }),&#10;      });&#10;    }&#10;  }, [roomCode, playerUuid, isConnected]);&#10;&#10;  return {&#10;    isConnected,&#10;    room,&#10;    activeGame, // This will now correctly be null after game ends&#10;    toggleReady,&#10;    startGame,&#10;    handleCardOpened,&#10;    masterRoleIsSetToVoteTime,&#10;    playerVote,&#10;    hostSummary,&#10;  };&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/enums/RoomStatus.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/enums/RoomStatus.java" />
              <option name="originalContent" value="package com.insidergame.insider_api.enums;&#10;&#10;public enum RoomStatus {&#10;    WAITING ,&#10;    PLAYING,&#10;}&#10;" />
              <option name="updatedContent" value="package com.insidergame.insider_api.enums;&#10;&#10;public enum RoomStatus {&#10;    WAITING ,&#10;    PLAYING,&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>