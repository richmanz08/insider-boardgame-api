<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/NGROK_WEBSOCKET_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/NGROK_WEBSOCKET_GUIDE.md" />
              <option name="updatedContent" value="# การใช้งาน WebSocket ผ่าน ngrok&#10;&#10;## ✅ Configuration ที่ทำไว้แล้ว&#10;&#10;### 1. **application.properties**&#10;```properties&#10;# CORS - Allow all origins (including ngrok)&#10;spring.web.cors.allowed-origins=*&#10;spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS&#10;spring.web.cors.allowed-headers=*&#10;spring.web.cors.allow-credentials=false&#10;&#10;# WebSocket - Allow all origins&#10;spring.websocket.allowed-origins=*&#10;```&#10;&#10;### 2. **WebSocketConfig.java**&#10;```java&#10;registry.addEndpoint(&quot;/ws&quot;)&#10;    .setAllowedOriginPatterns(&quot;*&quot;) // Allow all origins including ngrok&#10;    .withSockJS();&#10;```&#10;&#10;---&#10;&#10;##  วิธีใช้งานกับ ngrok&#10;&#10;### ขั้นที่ 1: Start Backend&#10;```bash&#10;# Run Spring Boot application&#10;./mvnw spring-boot:run&#10;&#10;# หรือ&#10;java -jar target/insider-api.jar&#10;```&#10;&#10;Backend จะรันที่: `http://localhost:8080`&#10;&#10;### ขั้นที่ 2: Start ngrok&#10;```bash&#10;# Expose port 8080 ผ่าน ngrok&#10;ngrok http 8080&#10;```&#10;&#10;คุณจะได้ URL เช่น:&#10;```&#10;Forwarding: https://abc123.ngrok.io -&gt; http://localhost:8080&#10;```&#10;&#10;### ขั้นที่ 3: เชื่อมต่อจาก Client&#10;&#10;#### Frontend (.env)&#10;```env&#10;NEXT_PUBLIC_API_URL=https://abc123.ngrok.io&#10;NEXT_PUBLIC_WS_URL=https://abc123.ngrok.io/ws&#10;```&#10;&#10;#### JavaScript/TypeScript&#10;```typescript&#10;import SockJS from &quot;sockjs-client&quot;;&#10;import { Client } from &quot;@stomp/stompjs&quot;;&#10;&#10;// Use ngrok URL&#10;const WS_URL = &quot;https://abc123.ngrok.io/ws&quot;;&#10;&#10;const client = new Client({&#10;  webSocketFactory: () =&gt; new SockJS(WS_URL),&#10;  reconnectDelay: 5000,&#10;  heartbeatIncoming: 4000,&#10;  heartbeatOutgoing: 4000,&#10;});&#10;&#10;client.onConnect = () =&gt; {&#10;  console.log(&quot;Connected via ngrok!&quot;);&#10;  &#10;  // Subscribe to room updates&#10;  client.subscribe(&quot;/topic/room/ROOMCODE&quot;, (message) =&gt; {&#10;    console.log(&quot;Received:&quot;, JSON.parse(message.body));&#10;  });&#10;  &#10;  // Send message&#10;  client.publish({&#10;    destination: &quot;/app/room/ROOMCODE/join&quot;,&#10;    body: JSON.stringify({ playerUuid: &quot;xxx&quot; })&#10;  });&#10;};&#10;&#10;client.activate();&#10;```&#10;&#10;---&#10;&#10;##  ทดสอบการเชื่อมต่อ&#10;&#10;### Test WebSocket Endpoint&#10;```bash&#10;curl https://abc123.ngrok.io/ws&#10;```&#10;&#10;Expected: HTML response from SockJS&#10;&#10;### Test REST API&#10;```bash&#10;curl https://abc123.ngrok.io/api/rooms&#10;```&#10;&#10;---&#10;&#10;##  ทดสอบจาก Mobile/External Device&#10;&#10;### 1. เปิด ngrok URL บน Mobile Browser&#10;```&#10;https://abc123.ngrok.io&#10;```&#10;&#10;### 2. Test WebSocket Connection&#10;- Frontend app จะเชื่อมต่อผ่าน ngrok URL&#10;- WebSocket จะทำงานแบบ real-time เหมือนปกติ&#10;&#10;---&#10;&#10;## ⚠️ สิ่งที่ต้องระวัง&#10;&#10;### 1. **HTTPS vs HTTP**&#10;ngrok ให้ HTTPS ฟรี แต่ถ้าใช้ free plan:&#10;- URL จะเปลี่ยนทุกครั้งที่ restart ngrok&#10;- ต้องอัพเดต frontend `.env` ทุกครั้ง&#10;&#10;### 2. **Session Persistence**&#10;ngrok free plan อาจมี session timeout:&#10;- WebSocket อาจ disconnect หลัง idle นาน&#10;- ใช้ `reconnectDelay` ใน STOMP client&#10;&#10;### 3. **Rate Limits**&#10;ngrok free plan มี rate limit:&#10;- 40 connections/minute&#10;- 20 req/second&#10;- เพียงพอสำหรับ development&#10;&#10;---&#10;&#10;##  Production Configuration&#10;&#10;⚠️ **สำหรับ Production ห้ามใช้ `*` (wildcard)**&#10;&#10;แก้ไข `application.properties`:&#10;```properties&#10;# Production - Specify exact origins&#10;spring.web.cors.allowed-origins=https://yourdomain.com,https://app.yourdomain.com&#10;spring.websocket.allowed-origins=https://yourdomain.com,https://app.yourdomain.com&#10;```&#10;&#10;แก้ไข `WebSocketConfig.java`:&#10;```java&#10;registry.addEndpoint(&quot;/ws&quot;)&#10;    .setAllowedOrigins(&#10;        &quot;https://yourdomain.com&quot;,&#10;        &quot;https://app.yourdomain.com&quot;&#10;    )&#10;    .withSockJS();&#10;```&#10;&#10;---&#10;&#10;##  Troubleshooting&#10;&#10;### Problem 1: WebSocket ไม่เชื่อมต่อ&#10;```&#10;Solution:&#10;1. Check ngrok running: ngrok http 8080&#10;2. Check backend running: curl http://localhost:8080/ws&#10;3. Check frontend WS_URL matches ngrok URL&#10;4. Check browser console for CORS errors&#10;```&#10;&#10;### Problem 2: 403 Forbidden&#10;```&#10;Solution:&#10;1. Verify CORS config in application.properties&#10;2. Restart backend after config change&#10;3. Clear browser cache&#10;```&#10;&#10;### Problem 3: Connection keeps dropping&#10;```&#10;Solution:&#10;1. Increase heartbeat intervals&#10;2. Add reconnect logic in client&#10;3. Check ngrok session timeout&#10;4. Use ngrok paid plan for stable sessions&#10;```&#10;&#10;### Problem 4: &quot;WebSocket connection failed&quot;&#10;```&#10;Solution:&#10;1. Try HTTP endpoint first: http://xxx.ngrok.io/ws&#10;2. Check if SockJS fallback works&#10;3. Verify no firewall blocking WebSocket&#10;4. Test on different network&#10;```&#10;&#10;---&#10;&#10;##  Monitor ngrok Traffic&#10;&#10;### View ngrok Dashboard&#10;```&#10;http://localhost:4040&#10;```&#10;&#10;จะเห็น:&#10;- All HTTP requests&#10;- WebSocket upgrade requests&#10;- Response times&#10;- Status codes&#10;&#10;---&#10;&#10;##  Tips&#10;&#10;### 1. **ใช้ ngrok config file**&#10;สร้าง `ngrok.yml`:&#10;```yaml&#10;authtoken: YOUR_AUTH_TOKEN&#10;tunnels:&#10;  insider-api:&#10;    proto: http&#10;    addr: 8080&#10;    subdomain: insider-game  # Requires paid plan&#10;```&#10;&#10;Run:&#10;```bash&#10;ngrok start insider-api&#10;```&#10;&#10;### 2. **Fixed URL (Paid Plan)**&#10;```bash&#10;ngrok http 8080 --subdomain=insider-game&#10;# URL จะเป็น: https://insider-game.ngrok.io (ไม่เปลี่ยน)&#10;```&#10;&#10;### 3. **Multiple Clients**&#10;```bash&#10;# Start multiple ngrok tunnels&#10;ngrok http 8080 --region=us&#10;ngrok http 8080 --region=eu&#10;```&#10;&#10;---&#10;&#10;## ✅ สรุป&#10;&#10;**ตอนนี้ระบบพร้อมใช้งานกับ ngrok แล้ว!**&#10;&#10;1. ✅ CORS config: allow all origins&#10;2. ✅ WebSocket config: allow all origins  &#10;3. ✅ SockJS fallback: enabled&#10;4. ✅ HTTP (not HTTPS): simpler for ngrok&#10;&#10;**วิธีใช้**:&#10;```bash&#10;# 1. Start backend&#10;./mvnw spring-boot:run&#10;&#10;# 2. Start ngrok&#10;ngrok http 8080&#10;&#10;# 3. Update frontend .env with ngrok URL&#10;NEXT_PUBLIC_WS_URL=https://xxx.ngrok.io/ws&#10;&#10;# 4. Done! &#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/VOTE_FIX_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/VOTE_FIX_SUMMARY.md" />
              <option name="updatedContent" value="# Fix: activeGame.votes Not Showing After Player Vote&#10;&#10;## Problem&#10;After calling `playerVote()`, the `activeGame` field `votes` was not visible in the frontend.&#10;&#10;## Root Causes&#10;&#10;### 1. **Backend**: Votes field was missing from active_game response&#10;The `currentGame()` handler in `RoomWebSocketController` was not including the `votes` field when building the gameMap response.&#10;&#10;### 2. **Frontend**: No request for updated activeGame after voting&#10;The `playerVote()` function was sending the vote but not requesting the updated active game data to see the votes.&#10;&#10;### 3. **Frontend**: Missing VOTE_CAST trigger&#10;The room update subscription wasn't listening for `VOTE_CAST` events to trigger an active game refresh.&#10;&#10;## Solution&#10;&#10;### Backend Fix ✅&#10;**File**: `RoomWebSocketController.java`&#10;&#10;Added `votes` field to the active_game response payload:&#10;&#10;```java&#10;gameMap.put(&quot;votes&quot;, g.getVotes());&#10;```&#10;&#10;Now when clients request `/app/room/{roomCode}/active_game`, they receive:&#10;```json&#10;{&#10;  &quot;game&quot;: {&#10;    &quot;id&quot;: &quot;...&quot;,&#10;    &quot;votes&quot;: {&#10;      &quot;player-uuid-1&quot;: &quot;target-uuid-a&quot;,&#10;      &quot;player-uuid-2&quot;: &quot;target-uuid-b&quot;&#10;    },&#10;    &quot;cardOpened&quot;: {...},&#10;    ...&#10;  }&#10;}&#10;```&#10;&#10;### Frontend Fix ✅&#10;**File**: `useRoomWebSocket.ts` (or `useRoomWebSocket_updated.ts`)&#10;&#10;#### 1. Added VOTE_CAST listener&#10;```typescript&#10;if (&#10;  update.type === &quot;CARD_OPENED&quot; ||&#10;  update.type === &quot;GAME_STARTED&quot; ||&#10;  update.type === &quot;VOTE_CAST&quot; ||      // ← NEW&#10;  update.type === &quot;VOTE_STARTED&quot; ||   // ← NEW&#10;  (update.activeGame !== undefined &amp;&amp; update.activeGame !== null)&#10;) {&#10;  // Request updated active game&#10;  clientRef.current.publish({&#10;    destination: `/app/room/${roomCode}/active_game`,&#10;    body: JSON.stringify({ playerUuid }),&#10;  });&#10;}&#10;```&#10;&#10;#### 2. Auto-request after voting&#10;```typescript&#10;const playerVote = useCallback(&#10;  (targetPlayerUuid: string) =&gt; {&#10;    if (clientRef.current &amp;&amp; isConnected) {&#10;      // Send vote&#10;      clientRef.current.publish({&#10;        destination: `/app/room/${roomCode}/vote`,&#10;        body: JSON.stringify({ playerUuid, targetPlayerUuid }),&#10;      });&#10;      &#10;      // Immediately request active game to see updated votes&#10;      setTimeout(() =&gt; {&#10;        if (clientRef.current?.connected) {&#10;          clientRef.current.publish({&#10;            destination: `/app/room/${roomCode}/active_game`,&#10;            body: JSON.stringify({ playerUuid }),&#10;          });&#10;        }&#10;      }, 100);&#10;    }&#10;  },&#10;  [roomCode, playerUuid, isConnected]&#10;);&#10;```&#10;&#10;## How It Works Now&#10;&#10;### Flow:&#10;1. **Player clicks vote** → `playerVote(targetUuid)` called&#10;2. **Vote sent** → Server receives at `/app/room/{roomCode}/vote`&#10;3. **Server updates** → `GameManager.recordVote()` stores vote in `Game.votes` map&#10;4. **Server broadcasts** → `VOTE_CAST` message to `/topic/room/{roomCode}`&#10;5. **Frontend receives** → `VOTE_CAST` in room subscription&#10;6. **Frontend requests** → `/app/room/{roomCode}/active_game`&#10;7. **Server responds** → `/user/queue/active_game` with updated votes field&#10;8. **Frontend updates** → `setActiveGame(game)` with votes visible&#10;&#10;### Result:&#10;```typescript&#10;activeGame.votes = {&#10;  &quot;uuid-player-1&quot;: &quot;uuid-target-a&quot;,&#10;  &quot;uuid-player-2&quot;: &quot;uuid-target-b&quot;,&#10;  &quot;uuid-player-3&quot;: &quot;uuid-target-a&quot;&#10;}&#10;```&#10;&#10;## Testing&#10;1. Start a game with multiple players&#10;2. Trigger voting phase (master_end)&#10;3. Each player calls `playerVote(targetUuid)`&#10;4. Check browser console for:&#10;   - `️ Player is voting for: [uuid]`&#10;   - `Room update received: { type: &quot;VOTE_CAST&quot; }`&#10;   - ` Requesting active game after vote...`&#10;   - ` active_game (user queue) received: { votes: {...} }`&#10;5. Verify `activeGame.votes` object in React state contains all votes&#10;&#10;## Additional Notes&#10;- Votes can be changed (new vote overwrites previous vote from same voter)&#10;- Only participants (players with roles) can vote&#10;- The `votes` map is initialized as empty `{}` when game is created&#10;- Votes persist across reconnects (stored in server memory via GameManager)&#10;&#10;## Files Modified&#10;1. `/src/main/java/com/insidergame/insider_api/websocket/RoomWebSocketController.java`&#10;2. `/hooks/useRoomWebSocket.ts` (create updated version as `useRoomWebSocket_updated.ts`)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/WEBSOCKET_FIXED.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/WEBSOCKET_FIXED.md" />
              <option name="updatedContent" value="# ✅ แก้ไขปัญหา WebSocket Connection เรียบร้อยแล้ว!&#10;&#10;##  ปัญหาที่พบ&#10;&#10;ใน `.env` มีการตั้งค่าผิด:&#10;```env&#10;NEXT_PUBLIC_WS_URL=https://localhost:8080/ws  # ❌ ใช้ https:// ผิด!&#10;```&#10;&#10;**ผลลัพธ์**: SecurityError เพราะ backend รัน HTTP แต่พยายามเชื่อมต่อด้วย HTTPS&#10;&#10;---&#10;&#10;## ✅ วิธีแก้ที่ทำแล้ว&#10;&#10;### 1. แก้ไข `.env`:&#10;```env&#10;# สำหรับ Local Development&#10;NEXT_PUBLIC_API_BASE_URL=http://localhost:8080/api&#10;NEXT_PUBLIC_WS_URL=http://localhost:8080/ws&#10;```&#10;&#10;### 2. แก้ไข `useRoomWebSocket.ts`:&#10;```typescript&#10;// เปลี่ยน default fallback จาก https:// เป็น http://&#10;const WS_URL = process.env.NEXT_PUBLIC_WS_URL || &quot;http://localhost:8080/ws&quot;;&#10;```&#10;&#10;---&#10;&#10;##  การตั้งค่าที่ถูกต้อง&#10;&#10;### Scenario 1: Local Development (ไม่ใช้ ngrok)&#10;**Backend**: `http://localhost:8080`&#10;&#10;**Frontend `.env`**:&#10;```env&#10;NEXT_PUBLIC_API_BASE_URL=http://localhost:8080/api&#10;NEXT_PUBLIC_WS_URL=http://localhost:8080/ws&#10;```&#10;&#10;✅ **ใช้ http://** เพราะทั้ง frontend และ backend รันบน localhost&#10;&#10;---&#10;&#10;### Scenario 2: ngrok (HTTPS)&#10;**Backend**: `http://localhost:8080` (ยังคงเป็น HTTP)&#10;&#10;**ngrok**:&#10;```bash&#10;ngrok http 8080&#10;# ได้ URL: https://abc123.ngrok.io&#10;```&#10;&#10;**Frontend `.env`**:&#10;```env&#10;NEXT_PUBLIC_API_BASE_URL=https://abc123.ngrok.io/api&#10;NEXT_PUBLIC_WS_URL=https://abc123.ngrok.io/ws&#10;```&#10;&#10;✅ **ใช้ https://** เพราะ ngrok ทำ TLS termination ให้&#10;&#10;---&#10;&#10;##  วิธีเปลี่ยนระหว่าง Local ↔ ngrok&#10;&#10;### วิธีที่ 1: แก้ไข `.env` (แนะนำ)&#10;&#10;**Local Development**:&#10;```env&#10;NEXT_PUBLIC_WS_URL=http://localhost:8080/ws&#10;```&#10;&#10;**ngrok**:&#10;```env&#10;NEXT_PUBLIC_WS_URL=https://abc123.ngrok.io/ws&#10;```&#10;&#10;จากนั้น **restart frontend**:&#10;```bash&#10;npm run dev&#10;```&#10;&#10;---&#10;&#10;### วิธีที่ 2: Dynamic Detection (Advanced)&#10;&#10;แก้ไข `useRoomWebSocket.ts`:&#10;```typescript&#10;// Auto-detect ngrok or localhost&#10;const getWsUrl = () =&gt; {&#10;  // If env variable exists, use it&#10;  if (process.env.NEXT_PUBLIC_WS_URL) {&#10;    return process.env.NEXT_PUBLIC_WS_URL;&#10;  }&#10;  &#10;  // Auto-detect based on window location&#10;  if (typeof window !== 'undefined') {&#10;    const protocol = window.location.protocol === 'https:' ? 'https:' : 'http:';&#10;    const host = window.location.host; // includes port&#10;    &#10;    // If running on ngrok domain&#10;    if (host.includes('ngrok.io') || host.includes('ngrok-free.app')) {&#10;      return `https://${host}/ws`;&#10;    }&#10;    &#10;    // Default: localhost&#10;    return 'http://localhost:8080/ws';&#10;  }&#10;  &#10;  return 'http://localhost:8080/ws';&#10;};&#10;&#10;const WS_URL = getWsUrl();&#10;```&#10;&#10;---&#10;&#10;##  ตรวจสอบว่าทำงานถูกต้อง&#10;&#10;### 1. เปิด Browser Console&#10;ควรเห็น:&#10;```&#10; WebSocket Connected for room: XXX player: YYY&#10;```&#10;&#10;ไม่ควรเห็น:&#10;```&#10;❌ SecurityError: An insecure SockJS connection...&#10;```&#10;&#10;### 2. Network Tab&#10;- Filter: WS&#10;- ควรเห็น connection ไปที่ URL ที่ถูกต้อง&#10;- Status: 101 Switching Protocols (สำเร็จ)&#10;&#10;### 3. เช็ค URL ที่ใช้งาน&#10;เพิ่ม log:&#10;```typescript&#10;console.log(&quot; WS_URL:&quot;, WS_URL);&#10;```&#10;&#10;Expected:&#10;- **Local**: `http://localhost:8080/ws`&#10;- **ngrok**: `https://abc123.ngrok.io/ws`&#10;&#10;---&#10;&#10;##  สรุป&#10;&#10;### ✅ แก้แล้ว:&#10;1. เปลี่ยน `.env` จาก `https://` → `http://` สำหรับ localhost&#10;2. แก้ default fallback ใน code&#10;3. สร้าง `.env.example` สำหรับอ้างอิง&#10;&#10;###  Checklist:&#10;- ✅ Backend รันที่ `http://localhost:8080`&#10;- ✅ `.env` ใช้ `http://localhost:8080/ws`&#10;- ✅ Frontend code fallback เป็น `http://`&#10;- ✅ Restart frontend&#10;&#10;###  พร้อมใช้งาน!&#10;&#10;**Local Development**: ทำงานด้วย HTTP ✅&#10;&#10;**ngrok**: เปลี่ยน `.env` เป็น `https://abc123.ngrok.io/ws` แล้ว restart ✅&#10;&#10;---&#10;&#10;##  ไฟล์ที่เกี่ยวข้อง&#10;&#10;- ✅ `useRoomWebSocket.ts` - แก้ default URL&#10;- ✅ `.env` - ต้องแก้เป็น `http://localhost:8080/ws`&#10;- ✅ `.env.example` - สร้างใหม่เป็น template&#10;-  `FIX_NGROK_WEBSOCKET_HTTPS.md` - คู่มือสำหรับ ngrok&#10;-  `NGROK_WEBSOCKET_GUIDE.md` - วิธีใช้งาน ngrok&#10;&#10;---&#10;&#10;## ⚡ Quick Fix (ถ้ายังไม่ทำ)&#10;&#10;```bash&#10;# 1. แก้ .env&#10;echo &quot;NEXT_PUBLIC_WS_URL=http://localhost:8080/ws&quot; &gt; .env.local&#10;&#10;# 2. Restart frontend&#10;npm run dev&#10;&#10;# 3. Done! ✅&#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/enums/RoomStatus.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/insidergame/insider_api/enums/RoomStatus.java" />
              <option name="originalContent" value="package com.insidergame.insider_api.enums;&#10;&#10;public enum RoomStatus {&#10;    WAITING ,&#10;    PLAYING,&#10;}&#10;" />
              <option name="updatedContent" value="package com.insidergame.insider_api.enums;&#10;&#10;public enum RoomStatus {&#10;    WAITING ,&#10;    PLAYING,&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>